type SimplyNamedInterType = BasicInterType, TaggedInterType[<generic>], named(type_symbol(Symbol));

## AT THE MOMENT DeclInterType DOESN'T SEEM TO BE A SUPERSET OF NameableInterType,
## BUT EVERYTHING COMPILES JUST FINE. ISN'T THAT WEIRD?
type DeclInterType  = SymbolInterType, TupleInterType, RecordInterType, NamedInterType, UnionInterType,
                      TaggedInterType[UnionableInterType];


implicit prg : CompiledPrg {
  // Types used at the boundary between generated and host code
  [NeType] boundary_types {
    react_blocks_types = [t : b <- prg.react_blocks, t <- interface_types(b)];
    static_blocks_map = [b.name -> b : b <- prg.static_blocks];
    static_blocks_types = [t : b <- prg.static_blocks, t <- interface_types(b, static_blocks_map)];
    return react_blocks_types & static_blocks_types;
  }


  // Types with a user-defined name that need to be declared, and their corresponding definitions
  [NamedInterType -> NameableInterType] named_interface_types {
    let typedefs = prg.typedefs:
      // Creating all the required interface types
      inter_types = [interface_type(t) : t <- boundary_types];

      // Retrieving all type symbols that are referenced either directly or indirectly
      type_symbs = reachable_type_symbols(inter_types);

      // Mapping each type name to its corresponding interface type
      inter_type_defs = [
        ts -> interface_type(expand_top_level_type_refs(cast_ne_type(expand_type_ref(ts, typedefs))))
        : ts <- type_symbs
      ];
    ;

    // Filtering out the type symbols that do not correspond to a nameable type
    return [:named(ts) -> t : ts, t <- inter_type_defs, t :: NameableInterType];
  }


  // Types that need to be declared
  [DeclInterType] declared_types {
    let typedefs = prg.typedefs:
      direct_inter_types = [interface_type(t) : t <- boundary_types];
    ;
    indirect_inter_types = values(named_interface_types);
    redundant_types = [t2 : t1 <- direct_inter_types | t1 <- indirect_inter_types, t2 <- types_to_declare(t1)];
    ## BAD BAD BAD: IS THIS LINE OF CODE ACTUALLY SAFE?

print "-- -- -- -- -- -- -- -- -- -- -- -- -- -- --";
print "boundary_types";
print boundary_types;
print "named_interface_types";
print named_interface_types;
print "direct_inter_types";
print direct_inter_types;
print "indirect_inter_types";
print indirect_inter_types;
print "redundant_types";
print redundant_types;
print "[t : t <- redundant_types, t :: NamedInterType]";
print [t : t <- redundant_types, t :: NamedInterType];
print "[n : n, d <- named_interface_types]";
print [n : n, d <- named_interface_types];

    named_types_synonyms = [named_interface_types(t, !!) : t <- redundant_types, t :: NamedInterType];

print "named_types_synonyms";
print named_types_synonyms;

    return redundant_types - named_types_synonyms;
  }


  // Child/parent relationships between declared types
  [DeclInterType] decl_types_parents(DeclInterType child) {
    return [p : p <- child_parent(child, ?)];

    [DeclInterType, DeclInterType] child_parent = [c, t : t <- declared_types, c <- children(t)];

    [UnionAltInterType] children(<DeclInterType, TaggedInterType[NameableInterType]> type) =
      union(ts?)  = ts,
      named(_)    = if named_interface_types(type, *) then children(named_interface_types(type, !!)) else [],
      _           = [];
  }


  // Names of the declared interface types when passing data from the host language to Cell
  [DeclInterType -> String] input_types_names {
    reserved_names = []; ## IMPLEMENT IMPLEMENT IMPLEMENT
    return interface_type_names(declared_types, direction = :in, reserved_names = reserved_names);
  }


  // Declaration of the interface types in the host language -> Cell direction
  [DeclInterType -> String*] input_types_decls = [
    t -> type_decl(t, input_types_names, :in) : t, s <- input_types_names
  ];


  // Names of the declared interface types when passing data from Cell to the host language
  [DeclInterType -> String] output_types_names {
    reserved_names = []; ## IMPLEMENT IMPLEMENT IMPLEMENT

    names = interface_type_names(declared_types, direction = :out, reserved_names = reserved_names);
    decls = [t -> type_decl(t, names, :out) : t, unused_var <- names];

    loop
      conflicts = union([{
          in_name  = input_types_names(t, !!);
          out_name = names(t, !!);
          in_decl  = input_types_decls(t, !!);
          out_decl = decls(t, !!);
          return [t if in_name == out_name and in_decl != out_decl];
        } : t <- declared_types
      ]);

      return names if conflicts == [];

      reserved_names = reserved_names & [input_types_names(t, !!) : t <- conflicts];
      names = interface_type_names(declared_types, direction = :out, reserved_names = reserved_names);
    ;
  }


  // Declaration of the interface types in the Cell -> host language direction
  [DeclInterType -> String*] output_types_decls {
    return [t -> type_decl(t, output_types_names, :out) : t, s <- output_types_names];
  }


  // Input types documentation
  [DeclInterType -> String*] input_types_docs {
    let direction = :in:
      docs = [t -> type_decl(t, input_types_names, :in) : t, unused_var <- input_types_names];
    ;
    return docs;
  }


  // Output types documentation
  [DeclInterType -> String*] output_types_docs {
    let direction = :out:
      docs = [t -> type_decl(t, output_types_names, :out) : t, unused_var <- output_types_names];
    ;
    return docs;
  }


  // Interface type declarations, for both input and output
  [String*] interface_types_decls = values(input_types_decls) & values(output_types_decls);


  // Documentation for the generated types, for both input and output
  [String*] interface_types_docs = values(input_types_docs) & values(output_types_docs);


  // Names of the conversion functions for both input and output types
  String decl_type_import_function(DeclInterType it) = "import" & input_types_names(it, !!);
  String decl_type_export_function(DeclInterType it) = "export" & output_types_names(it, !!);
}


// implicit host_to_cell : Bool, reserved_names : [String] {
//   ( [InterType -> String], [InterType -> String],
//     [NamedInterType -> String], [NamedInterType -> String],
//     [String*], [String*]
//   ) declared_types([NeType] types) {
//     named_types = named_interface_types(types);
//     inter_types = [interface_type(t) : t <- types] & values(named_types);
//     decl_types = union([types_to_declare(t) : t <- inter_types]);

//     child_parent = [c, t : t <- decl_types, c <- children(t, named_types)];
//     parents = [c -> [p : p <- child_parent(c, ?)] : c, unused_var <- child_parent];

//     reserved_names = []; ## IMPLEMENT
//     let reserved_names = reserved_names:
//       types_names_input  = interface_type_names(decl_types, direction = :in);
//       types_names_output = interface_type_names(decl_types, direction = :out);
//     ;

//     named_type_import_function = [n -> "import" & types_names_input(n, !!)  : n, unused_var <- named_types];
//     named_type_export_function = [n -> "export" & types_names_output(n, !!) : n, unused_var <- named_types];

//     let input_types_names = types_names_input, named_type_import_function = named_type_import_function,
//         output_types_names = types_names_output, named_type_export_function = named_type_export_function,
//         parents = parents:
//       input_types_decls  = [t -> type_decl(t, direction = :in)  : t, s <- types_names_input];
//       output_types_decls = [t -> type_decl(t, direction = :out) : t, s <- types_names_output];
//     ;

//     loop
//       conflicts = union([{
//           in_name  = types_names_input(t, !!);
//           out_name = types_names_output(t, !!);
//           in_decl  = input_types_decls(t, !!);
//           out_decl = output_types_decls(t, !!);
//           return [t if in_name == out_name and in_decl != out_decl];
//         } : t <- decl_types
//       ]);

//       break if conflicts == [];

//       reserved_names = reserved_names & [types_names_input(t, !!) : t <- conflicts];
//       let reserved_names = reserved_names:
//         types_names_output = interface_type_names(decl_types, direction = :out);
//       ;
//       named_type_export_function = [n -> types_names_output(n, !!) : n, unused_var <- named_types];

//       let input_types_names = types_names_input, named_type_import_function = named_type_import_function,
//           output_types_names = types_names_output, named_type_export_function = named_type_export_function,
//           parents = parents, direction = :out:
//         output_types_decls = [t -> type_decl(t) : t, s <- types_names_output];
//       ;
//     ;

//     let input_types_names = types_names_input, named_type_import_function = named_type_import_function,
//         output_types_names = types_names_output, named_type_export_function = named_type_export_function,
//         parents = parents:
//       input_types_docs  = [t -> type_docs(t, direction = :in)  : t, s <- types_names_input];
//       output_types_docs = [t -> type_docs(t, direction = :out) : t, s <- types_names_output];
//     ;

//     type_decls = values(input_types_decls) & values(output_types_decls);
//     type_docs  = values(input_types_docs)  & values(output_types_docs);

//     return (
//       types_names_input, types_names_output,
//       named_type_import_function, named_type_export_function,
//       type_decls, type_docs
//     );
//   }


//   [UnionAltInterType] children(<DeclInterType, NameableInterType> type,
//       [NamedInterType -> NameableInterType] named_types) =
//     union(ts?)  = ts,
//     named(_)    = if named_types(type, *) then children(named_types(type, !!), named_types) else [],
//     _           = [];
// }


[DeclInterType] types_to_declare(InterType inter_type) =
  bool            |
  integer         |
  float           |
  symbol          |
  string          |
  generic         = [],
  symbol()        = [inter_type],
  tuple(ts?)      = [inter_type] & union([types_to_declare(t) : t <~ ts]),
  record(fs?)     = [inter_type] & union([types_to_declare(t) : l, t <- fs]),
  seq(t?)         |
  set(t?)         = types_to_declare(t),
  bin_rel(ts?)    |
  tern_rel(ts?)   = union([types_to_declare(t) : t <~ ts]),
  tagged(_, t?)   = types_to_declare(t),
  named()         = [inter_type],
  union(ts?)      = [inter_type] & ts & #(union([types_to_declare(t) : t <- ts]) - [strip_tags(t) : t <- ts]);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

implicit reserved_names : [String], direction : <in, out> {
  [DeclInterType -> String] interface_type_names([DeclInterType] decl_types) {
    type_names = [t -> safe_name(t, nothing) : t <- decl_types];
    loop
      conflicts = non_injective_keys_by_value(type_names);
      break if conflicts == [];
      renamed_types = [t -> safe_name(t, just(i)) : ts <- conflicts, t @ i <~ isort(ts)];
      type_names = [t -> lookup(renamed_types, t, type_names(t, !!)) : t <- decl_types];

      ## THIS IS JUST A CHECK THAT HAS TO BE REMOVED
      assert {
        rem_conflicts = non_injective_keys_by_value(type_names);
        if rem_conflicts != []:
          print "Found conflict after first iteraction of renaming:";
          print rem_conflicts;
        ;
        return true;
      };
    ;
    return type_names;
  }


  String safe_name(TupleInterType type, Maybe[Nat] unique_id) {
    suffix = if unique_id != nothing then "_" & printed(value(unique_id)) else "";
    field_types = untag(type);
    name = if field_types :: SimplyNamedInterType+
      then append((field_type_name(t) : t <- field_types), "_")
      else "Tuple";
    return non_reserved_name(name & suffix);

    String field_type_name(SimplyNamedInterType) =
      bool                = "Bool",
      integer             = "Long",
      float               = "Double",
      symbol              = "Symbol",
      string              = "String",
      generic             |
      tagged(_, generic)  = if direction == :in then "String" else "Value",
      named(ts?)          = upper_camel_case(match(ts) type_symbol(s?) = s);
  }


  String safe_name(SymbolInterType type, Maybe[Nat] unique_id) {
    suffix = if unique_id != nothing then "_" & printed(value(unique_id)) else "";
    base_name = upper_camel_case(untag(type));
    return non_reserved_name(base_name & suffix);
  }


  String safe_name(RecordInterType type, Maybe[Nat] unique_id) {
    suffix = if unique_id != nothing then "_" & printed(value(unique_id)) else "";
    field_labels = isort(keys(untag(type)));
    base_name = append((upper_camel_case(l) : l <- field_labels), "_");
    return non_reserved_name(base_name & suffix);
  }


  String safe_name(NamedInterType type, Maybe[Nat] unique_id) {
    suffix = if unique_id != nothing then "_" & printed(value(unique_id)) else "";
    type_symb = match (type) named(ts?) = ts;
    return non_reserved_name(base_name(type_symb) & suffix);


    String base_name(BasicTypeSymbol) =
      type_symbol(s?)         |
      schema_type_symbol(s?)  = upper_camel_case(s),
      builtin_type_symbol()   = undefined;

    String base_name(ParTypeSymbol type_symb) {
      ## IMPLEMENT FOR REAL...
      return base_name(type_symb.symbol);
    }
  }


  String safe_name(TaggedInterType[UnionableInterType] type, Maybe[Nat] unique_id) {
    suffix = if unique_id != nothing then "_" & printed(value(unique_id)) else "";
    tag = match (type) tagged(s?, _) = s;
    return non_reserved_name(upper_camel_case(tag) & suffix);
  }


  String safe_name(UnionInterType type, Maybe[Nat] unique_id) {
    suffix = if unique_id != nothing then "_" & printed(value(unique_id)) else "";
    return non_reserved_name("TypeUnion" & suffix);
  }


  String non_reserved_name(String unsafe_name) {
    name = unsafe_name;
    while reserved_names(name):
      name = "_" & name;
    ;
    return name;
  }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

implicit prg : CompiledPrg {
  String* type_decl(DeclInterType type, [DeclInterType -> String] types_names, <in, out> direction) =
    type_decl_or_doc(type, types_names = types_names, direction = direction, doc_only = false, root_type = type);

  String* type_docs(DeclInterType type, [DeclInterType -> String] types_names, <in, out> direction) =
    type_decl_or_doc(type, types_names = types_names, direction = direction, doc_only = true, root_type = type);
}


implicit prg : CompiledPrg, types_names : [DeclInterType -> String], direction : <in, out>,
         doc_only : Bool, root_type : DeclInterType {

  String* type_decl_or_doc(TupleInterType type) {
    types = match (direction)
      in  = (input_arg_type(t) : t @ i <- untag(type)),
      out = (return_value_type(t, types_names) : t @ i <- untag(type));
    max_len = max((length(t) : t <- types));
    spaces = (string((ascii_space : i < max_len - length(t))) : t <- types);
    body = ("  public " & t & spaces(i) & " item" & printed(i) & ";" : t @ i <- types);
    header = #(if doc_only then "" else "public static ") & "class " & name_and_parents_decl & " {";
    return (header) & body & ("}");
  }


  String* type_decl_or_doc(RecordInterType type) {
    fields = match (direction)
      in  = [l -> input_arg_type(t) : l, t <- untag(type)],
      out = [l -> return_value_type(t, types_names) : l, t <- untag(type)];
    field_names = java_adjusted_unambiguous_lower_camel_case_names(keys(fields));
    max_len = max([length(t) : unused_var, t <- fields]);
    body = ({
        spaces = string((ascii_space : unused_var < max_len - length(t)));
        return "  public " & t & spaces & " " & field_names(l, !!) & ";";
      } : l, t <- isort(fields)
    );
    header = #(if doc_only then "" else "public static ") & "class " & name_and_parents_decl & " {";
    return (header) & body & ("}");
  }


  String* type_decl_or_doc(NamedInterType type) {
    return nameable_type_decl(named_interface_types(type, !!));

    String* nameable_type_decl(<TupleInterType, RecordInterType, UnionInterType> type) =
      type_decl_or_doc(type);

    String* nameable_type_decl(TaggedInterType[NameableInterType] type) =
      tagged(_, t?) = nameable_type_decl(t);
  }


  String* type_decl_or_doc(TaggedInterType[UnionableInterType] type) {
    return match (type)
      tagged(_, t?) = type_decl_or_doc(t);
  }


  String* type_decl_or_doc(UnionInterType type) = (
    "interface " & name_and_parents_decl & " {",
    "",
    "}"
  );


  String* type_decl_or_doc(SymbolInterType type) {
    type_name = types_names(root_type, !!);
    first_line = #(if doc_only then "" else "public static ") & "class " & name_and_parents_decl & " {";
    body = (
      type_name & "() {",
      "",
      "}",
      "",
      "static " & type_name & " singleton = new " & type_name & "();",
      "",
      "public static " & type_name & " singleton() {",
      "  return singleton;",
      "}"
    );
    return (first_line) & #(if doc_only then ("") else indent_lines(body)) & ("}");
  }


  String name_and_parents_decl {
    text = types_names(root_type, !!);
    parents = decl_types_parents(root_type);
    text = text & " implements " & append((types_names(p, !!) : p <- isort(parents)), ", ") if parents != [];
    return text;
  }
}


[Symbol -> String] java_adjusted_unambiguous_lower_camel_case_names([Symbol] symbols) {
  nice_field_names = [s -> safe_lower_camel_case(s, false) : s <- symbols];
  conflicting_names = duplicate_values(nice_field_names);
  return [
    l -> if conflicting_names(n) then safe_lower_camel_case(l, true) else n
    : l, n <- nice_field_names
  ];
}

////////////////////////////////////////////////////////////////////////////////

// [InterType -> String] java_type_names([NamedInterType] types) = [
//   ## THIS SHOULD ALSO RESOLVE CONFLICTS WITH OTHER UPPER CAMEL CASE NAMES
//   t -> upper_camel_case(s) : type <- types, named(s?, t?) ?= type
// ];


String safe_lower_camel_case(Symbol symb) = safe_lower_camel_case(symb, false);


String safe_lower_camel_case(Symbol symb, Bool keep_underscore) {
  name = lower_camel_case(symb);
  name = "_" & name if is_reserved(name);
  return name;
}

String safe_lower_camel_case_chain(Symbol+ symbs) {
  name = append((lower_camel_case(s) : s <- symbs), "_");
  name = "_" & name if is_reserved(name);
  return name;
}

////////////////////////////////////////////////////////////////////////////////

InterType strip_tags(InterType type) =
  tagged(_, t?) = strip_tags(t),
  _             = type;

////////////////////////////////////////////////////////////////////////////////

[V] duplicate_values([K -> V] map) = duplicates((v : unused_var, v <- isort(map)));

[K] non_injective_keys([K -> V] map) {
  dup_vals = duplicate_values(map);
  return [k : k, v <- map, dup_vals(v)];
}

[K -> V] remove_non_injective_keys([K -> V] map) {
  keys_to_remove = non_injective_keys(map);
  return [k -> v : k, v <- map, not keys_to_remove(k)];
}

[[+K]] non_injective_keys_by_value([K -> V] map) =
  values(group_by(non_injective_keys(map), map($, !!)));
