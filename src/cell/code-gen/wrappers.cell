type AtomicInterType  = bool, integer, float, symbol, string;
type BasicInterType   = AtomicInterType, generic;

type TupleInterType   = tuple(InterType+);
type RecordInterType  = record([+Symbol -> InterType]);
type TaggedInterType  = tagged(SymbObj, InterType);

type NamedInterType   = named(type_symbol(Atom), <TupleInterType, RecordInterType, TaggedInterType>);

type CollInterType    = seq(InterType),
                        set(InterType),
                        bin_rel(InterType, InterType),
                        tern_rel(InterType, InterType, InterType);

type InterType        = BasicInterType,
                        TupleInterType,
                        RecordInterType,
                        CollInterType,
                        TaggedInterType,
                        NamedInterType;


NeType internal_type(AtomicInterType) =
  bool        = type_bool,
  integer     = integer,
  float       = float_type,
  symbol      = atom_type,
  string      = type_string;


implicit input_types_names : [InterType -> String] {
  String input_arg_type(InterType it) =
    bool              = "boolean",
    integer           = "long",
    float             = "double",
    tuple()           |
    record()          = input_types_names(it, !!),
    named(n?, t?)     = if input_types_names(it, *) then input_types_names(it, !!) else input_arg_type(t),
    seq(t?)           |
    set(t?)           = input_arg_type(t) & "[]",
    bin_rel(t1?, t2?) = "Pair<" & input_arg_type(t1) & "[], " & input_arg_type(t2) & "[]>",
    tern_rel(ts?)     = "Triplet<" & append((input_arg_type(t) & "[]" : t <- ts), ", ") & ">",
    tagged(_, t?)     = input_arg_type(t),
    symbol            |
    string            |
    generic           = "String";


  String* import_code(InterType it, String expr, String action_prefix) =
    bool                    = (action_prefix & "SymbObj.get(" & expr & ");"),
    integer                 = (action_prefix & "IntObj.get(" & expr & ");"),
    float                   = (action_prefix & "new FloatObj(" & expr & ");"),
    symbol                  = (action_prefix & "Conversions.convertText(" & expr & ");"),
    string                  = (action_prefix & "Conversions.stringToObj(" & expr & ");"),
    tuple(ts?)              = tuple_import_code(ts, expr, action_prefix),
    record(fs?)             = record_import_code(fs, expr, action_prefix),
    named(_, t?)            = import_code(t, expr, action_prefix),
    seq(t?)                 = array_import_code(t, expr, action_prefix, "new MasterSeqObj"),
    set(t?)                 = array_import_code(t, expr, action_prefix, "Builder.createSet"),
    bin_rel(t1?, t2?)       = bin_rel_import_code(t1, t2, expr, action_prefix),
    tern_rel(t1?, t2?, t3?) = tern_rel_import_code(t1, t2, t3, expr, action_prefix),
    tagged(_, generic)      = import_code(:generic, expr, action_prefix),
    tagged(s?, t?)          = tagged_value_import_code(s, t, expr, action_prefix),
    generic                 = (action_prefix & "Conversions.convertText(" & expr & ");");


  String* record_import_code([+Symbol -> InterType] fields, String expr, String action_prefix) {
    unique_id = printed(_counter_(:any_value_will_do));
    keys_var = "keys_" & unique_id;
    values_var = "values_" & unique_id;

    count = |fields|;

    code = (
      "Obj[] " & keys_var   & " = new Obj[" & printed(count) & "];",
      "Obj[] " & values_var & " = new Obj[" & printed(count) & "];"
    );

    field_names = java_adjusted_unambiguous_lower_camel_case_names(keys(fields));
    for l, n @ i <- isort(field_names):
      code = (code | keys_var & "[" & printed(i) & "] = " & native_expr(object(l)) & ";");
      field_expr = expr & "." & field_names(l, !!);
      asgnm_prefix = values_var & "[" & printed(i) & "] = ";
      code = code & import_code(fields(l, !!), field_expr, asgnm_prefix);
    ;

    map_creation_expr = "Builder.createMap(" & keys_var & ", " & values_var & ", " & printed(count) & ")";
    return (code | action_prefix & map_creation_expr & ";");
  }


  String* tuple_import_code(InterType+ types, String expr, String action_prefix) {
    unique_id = printed(_counter_(:any_value_will_do));
    // expr_var = "expr" & unique_id;

    field_vars = ("field" & printed(i) & "_" & unique_id : t @ i <- types);
    fields_code = (import_code(t, expr & ".item" & printed(i), "Obj " & field_vars(i) & " = ") : t @ i <- types);

    tuple_instr = action_prefix & "new MasterSeqObj(new Obj[] {" & append(field_vars, ", ") & "});";

    return (join(fields_code) | tuple_instr);

    // ## BAD, I'M RECONSTRUCTING THE InterType VALUE AFTER DESTROYING IT
    // return (input_arg_type(:tuple(types)) & " " & expr_var & " = " & expr & ";") &
    //        (join(fields_code) | tuple_instr);
  }


  String* array_import_code(InterType elem_type, String expr, String action_prefix, String ctor) {
    unique_id = printed(_counter_(:any_value_will_do));
    expr_var = "expr" & unique_id;
    idx_var = "idx" & unique_id;
    array_var = "array" & unique_id;

    elem_code = import_code(elem_type, expr_var & "[" & idx_var & "]", array_var & "[" & idx_var & "] = ");

    return indent_lines((
        input_arg_type(elem_type) & "[] " & expr_var & " = " & expr & ";",
        "Obj[] " & array_var & " = new Obj[" & expr_var & ".length];",
        "for (int " & idx_var & " = 0 ; " & idx_var & " < " & expr_var & ".length ; " & idx_var & "++) {"
      ) & indent_lines(elem_code) & (
        "}",
        action_prefix & ctor & "(" & array_var & ");"
      )
    );
  }


  String* bin_rel_import_code(InterType arg1_type, InterType arg2_type, String expr, String action_prefix) {
    unique_id = printed(_counter_(:any_value_will_do));
    expr_var  = "expr" & unique_id;
    len_var   = "len" & unique_id;
    idx_var   = "idx" & unique_id;
    col1_var  = "col1_" & unique_id;
    col2_var  = "col2_" & unique_id;

    arg1_code = import_code(arg1_type, expr_var & ".item1[" & idx_var & "]", col1_var & "[" & idx_var & "] = ");
    arg2_code = import_code(arg2_type, expr_var & ".item2[" & idx_var & "]", col2_var & "[" & idx_var & "] = ");

    rel_type = :bin_rel(arg1_type, arg2_type); ## BAD, RECONSTRUCTING PREVIOUSLY DESTRUCTED VALUE

    return indent_lines((
        input_arg_type(rel_type) & " " & expr_var & " = " & expr & ";",
        "int " & len_var & " = " & expr_var & ".length;",
        "Obj[] " & col1_var & " = new Obj[" & len_var & "];",
        "Obj[] " & col2_var & " = new Obj[" & len_var & "];",
        "for (int " & idx_var & " = 0 ; " & idx_var & " < " & len_var & " ; " & idx_var & "++) {"
      ) & indent_lines(arg1_code & arg2_code) & (
        "}",
        action_prefix & "Builder.createBinRel(" & col1_var & ", " & col2_var & ");"
      )
    );
  }


  String* tern_rel_import_code(InterType arg1_type, InterType arg2_type, InterType arg3_type, String expr, String action_prefix) {
    unique_id = printed(_counter_(:any_value_will_do));
    expr_var  = "expr" & unique_id;
    len_var   = "len" & unique_id;
    idx_var   = "idx" & unique_id;
    col1_var  = "col1_" & unique_id;
    col2_var  = "col2_" & unique_id;
    col3_var  = "col3_" & unique_id;

    arg1_code = import_code(arg1_type, expr_var & ".item1[" & idx_var & "]", col1_var & "[" & idx_var & "] = ");
    arg2_code = import_code(arg2_type, expr_var & ".item2[" & idx_var & "]", col2_var & "[" & idx_var & "] = ");
    arg3_code = import_code(arg3_type, expr_var & ".item3[" & idx_var & "]", col3_var & "[" & idx_var & "] = ");

    rel_type = :tern_rel(arg1_type, arg2_type, arg3_type); ## BAD, RECONSTRUCTING PREVIOUSLY DESTRUCTED VALUE

    return indent_lines((
        input_arg_type(rel_type) & " " & expr_var & " = " & expr & ";",
        "int " & len_var & " = " & expr_var & ".length;",
        "Obj[] " & col1_var & " = new Obj[" & len_var & "];",
        "Obj[] " & col2_var & " = new Obj[" & len_var & "];",
        "Obj[] " & col3_var & " = new Obj[" & len_var & "];",
        "for (int " & idx_var & " = 0 ; " & idx_var & " < " & len_var & " ; " & idx_var & "++) {"
      ) & indent_lines(arg1_code & arg2_code & arg3_code) & (
        "}",
        action_prefix & "Builder.createBinRel(" & col1_var & ", " & col2_var & ", " & col3_var & ");"
      )
    );
  }


  String* tagged_value_import_code(SymbObj tag, InterType inner_type, String expr, String action_prefix) {
    unique_id = printed(_counter_(:any_value_will_do));
    inner_var = "inner" & unique_id;

    inner_code = import_code(inner_type, expr, "Obj " & inner_var & " = ");
    creation_instr = action_prefix & "new TaggedObj(" & symb_idx_name(tag) & ", " & inner_var & ");";

    return (inner_code | creation_instr);
  }
}


implicit output_types_names : [InterType -> String] {
  String return_value_type(InterType it) =
    bool          = "boolean",
    integer       = "long",
    float         = "double",
    symbol        = "String",
    string        = "String",
    tuple()       |
    record()      = output_types_names(it, !!),
    named(n?, t?) = if output_types_names(it, *) then output_types_names(it, !!) else return_value_type(t),
    seq(t?)       |
    set(t?)       = return_value_type(t) & "[]",
    bin_rel(ts?)  = "Pair<" & append((return_value_type(t) & "[]" : t <- ts), ", ") & ">",
    tern_rel(ts?) = "Triplet<" & append((return_value_type(t) & "[]" : t <- ts), ", ") & ">",
    tagged(_, t?) = if t != :generic then return_value_type(t) else return_value_type(:generic),
    generic       = "Value";


  String* export_code(InterType it, String expr, String action_prefix) =
    bool                = (action_prefix & expr & ".getBool();"),
    integer             = (action_prefix & expr & ".getLong();"),
    float               = (action_prefix & expr & ".getDouble();"),
    symbol              = (action_prefix & expr & ".toString();"),
    string              = (action_prefix & expr & ".getString();"),
    tuple(ts?)          = tuple_export_code(ts, output_types_names(it, !!), expr, action_prefix),
    record(fs?)         = record_export_code(fs, output_types_names(it, !!), expr, action_prefix),
    named()             = named_type_export_code(it, expr, action_prefix),
    seq(t?)             |
    set(t?)             = array_export_code(t, expr, action_prefix),
    bin_rel(t1?, t2?)   = bin_rel_export_code(t1, t2, expr, action_prefix),
    tern_rel(t1?, t2?, t3?) = tern_rel_export_code(t1, t2, t3, expr, action_prefix),
    tagged(_, generic)  = export_code(:generic, expr, action_prefix),
    tagged(_, t?)       = export_code(t, expr & ".getInnerObj()", action_prefix),
    generic             = (action_prefix & "Conversions.exportAsValue(" & expr & ");");


  String* named_type_export_code(NamedInterType inter_type, String expr, String action_prefix) =
    named(id?, tuple(ts?))  = tuple_export_code(ts, output_types_names(inter_type, !!), expr, action_prefix),
    named(id?, record(fs?)) = record_export_code(fs, output_types_names(inter_type, !!), expr, action_prefix),
    named(id?, tagged() t?) = if output_types_names(inter_type, *)
                              then tagged_value_export_code(t, output_types_names(inter_type, !!), expr, action_prefix)
                              else export_code(t, expr, action_prefix);


  String* tagged_value_export_code(TaggedInterType tagged_type, String type_name, String expr, String action_prefix) {
    untagged_expr = expr & ".getInnerObj()";
    inner_type = match (tagged_type) tagged(_, t?) = t;
    return match (inner_type)
      tuple(ts?)      = tuple_export_code(ts, type_name, untagged_expr, action_prefix),
      record(fs?)     = record_export_code(fs, type_name, untagged_expr, action_prefix),
      tagged(_, t?)   = tagged_value_export_code(inner_type, type_name, untagged_expr, action_prefix);
  }


  String* record_export_code([+Symbol -> InterType] fields, String type_name, String expr, String action_prefix) {
    unique_id = printed(_counter_(:any_value_will_do));
    record_var = "record_" & unique_id;

    field_names = java_adjusted_unambiguous_lower_camel_case_names(keys(fields));

    record_inst_instr = type_name & " " & record_var & " = new " & type_name & "();";
    asgnm_code = join(({
        asgnm_text = record_var & "." & field_names(l, !!) & " = ";
        return export_code(t, expr & ".lookupField(" & symb_idx_name(l) & ")", asgnm_text);
      } : l, t <- isort(fields)
    ));

    return (record_inst_instr) & (asgnm_code | action_prefix & record_var & ";");
  }


  String* tuple_export_code(InterType+ types, String type_name, String expr, String action_prefix) {
    unique_id = printed(_counter_(:any_value_will_do));
    tuple_var = "tuple_" & unique_id;

    tuple_instantiation_instr = type_name & " " & tuple_var & " = new " & type_name & "();";

    asgnm_code = join(({
        asgnm_text = tuple_var & ".item" & printed(i) & " = ";
        return export_code(t, expr & ".getItem(" & printed(i) & ")", asgnm_text);
      } : t @ i <- types
    ));

    return (tuple_instantiation_instr) & (asgnm_code | action_prefix & tuple_var & ";");
  }


  String* array_export_code(InterType elem_type, String expr, String action_prefix) {
    return match (elem_type)
      bool                = (action_prefix & "Conversions.toBoolArray(" & expr & ");"),
      integer             = (action_prefix & "Conversions.toLongArray(" & expr & ");"),
      float               = (action_prefix & "Conversions.toDoubleArray(" & expr & ");"),
      symbol              = (action_prefix & "Conversions.toSymbolArray(" & expr & ");"),
      string              = (action_prefix & "Conversions.toStringArray(" & expr & ");"),
      generic             = (action_prefix & "Conversions.toValueArray(" & expr & ");"),
      tagged(_, generic)  = array_export_code(:generic, expr, action_prefix),
      tuple()             |
      record()            |
      seq()               |
      set()               |
      named()             |
      tagged()            = generic_array_export_code(elem_type, expr, action_prefix);


    String* generic_array_export_code(InterType elem_type, String expr, String action_prefix) {
      unique_id = printed(_counter_(:any_value_will_do));
      expr_var = "expr" & unique_id;
      size_var = "size" & unique_id;
      array_var = "array" & unique_id;
      iter_var = "iter" & unique_id;
      idx_var = "idx" & unique_id;
      out_elem_type = return_value_type(elem_type);

      return (
        "Obj " & expr_var & " = " & expr & ";",
        "int " & size_var & " = " & expr_var & ".getSize();",
        out_elem_type & "[] " & array_var & " = new " & array_new_expr(elem_type, size_var) & ";",
        "SeqOrSetIter " & iter_var & " = " & expr_var & ".getSeqOrSetIter();",
        "int " & idx_var & " = 0;",
        "while (!" & iter_var & ".done()) {"
      ) & indent_lines(export_code(elem_type, iter_var & ".get()", array_var & "[" & idx_var & "++] = ")) & (
        "  " & iter_var & ".next();",
        "}",
        "Miscellanea._assert(" & idx_var & " == " & size_var & ");",
        action_prefix & array_var & ";"
      );
    }
  }


  String* bin_rel_export_code(InterType arg1_type, InterType arg2_type, String src_expr, String action_prefix) {
    unique_id = printed(_counter_(:any_value_will_do));
    expr_var, size_var, col1_var, col2_var, iter_var, idx_var = (
      s & "_" & unique_id : s <- ("expr", "size", "col1", "col2", "iter", "idx")
    );
    out_col1_type = return_value_type(arg1_type);
    out_col2_type = return_value_type(arg2_type);

    arg1_export_code = export_code(arg1_type, iter_var & ".get1()", col1_var & "[" & idx_var & "] = ");
    arg2_export_code = export_code(arg2_type, iter_var & ".get2()", col2_var & "[" & idx_var & "++] = ");

    return (
      "Obj " & expr_var & " = " & src_expr & ";",
      "int " & size_var & " = " & expr_var & ".getSize();",
      out_col1_type & "[] " & col1_var & " = new " & array_new_expr(arg1_type, size_var) & ";",
      out_col2_type & "[] " & col2_var & " = new " & array_new_expr(arg2_type, size_var) & ";",
      "BinRelIter " & iter_var & " = " & expr_var & ".getBinRelIter();",
      "int " & idx_var & " = 0;",
      "while (!" & iter_var & ".done()) {"
    ) & indent_lines(arg1_export_code & arg2_export_code) & (
      "  " & iter_var & ".next();",
      "}",
      "Miscellanea._assert(" & idx_var & " == " & size_var & ");",
      action_prefix & "new Pair<" & out_col1_type & "[], " & out_col2_type & "[]>(" &
        col1_var & ", " & col2_var & ");"
    );
  }


  String* tern_rel_export_code(InterType arg1_type, InterType arg2_type, InterType arg3_type, String src_expr, String action_prefix) {
    unique_id = printed(_counter_(:any_value_will_do));
    expr_var, size_var, col1_var, col2_var, col3_var, iter_var, idx_var = (
      s & "_" & unique_id : s <- ("expr", "size", "col1", "col2", "col3", "iter", "idx")
    );

    out_arg1_type = return_value_type(arg1_type);
    out_arg2_type = return_value_type(arg2_type);
    out_arg3_type = return_value_type(arg3_type);

    arg1_export_code = export_code(arg1_type, iter_var & ".get1()", col1_var & "[" & idx_var & "] = ");
    arg2_export_code = export_code(arg2_type, iter_var & ".get2()", col2_var & "[" & idx_var & "] = ");
    arg3_export_code = export_code(arg3_type, iter_var & ".get3()", col3_var & "[" & idx_var & "++] = ");

    return (
      "Obj " & expr_var & " = " & src_expr & ";",
      "int " & size_var & " = " & expr_var & ".getSize();",
      out_arg1_type & "[] " & col1_var & " = new " & array_new_expr(arg1_type, size_var) & ";",
      out_arg2_type & "[] " & col2_var & " = new " & array_new_expr(arg2_type, size_var) & ";",
      out_arg3_type & "[] " & col3_var & " = new " & array_new_expr(arg3_type, size_var) & ";",
      "TernRelIter " & iter_var & " = " & expr_var & ".getTernRelIter();",
      "int " & idx_var & " = 0;",
      "while (!" & iter_var & ".done()) {"
    ) & indent_lines(arg1_export_code & arg2_export_code & arg3_export_code) & (
      "  " & iter_var & ".next();",
      "}",
      "Miscellanea._assert(" & idx_var & " == " & size_var & ");",
      action_prefix & "new Triplet<" & out_arg1_type & "[], " & out_arg2_type & "[], " & out_arg3_type & "[]>(" &
        col1_var & ", " & col2_var & ", " & col3_var & ");"
    );
  }


  String array_new_expr(InterType elem_type, String size_expr) =
    seq(t?) | set(t?) = array_new_expr(t, size_expr) & "[]",
    _                 = return_value_type(elem_type) & "[" & size_expr & "]";
}

////////////////////////////////////////////////////////////////////////////////

implicit typedefs : [TypeName -> NeType] {
  InterType interface_type(NeType type) {
    for it <- (:bool, :integer, :float, :symbol, :string):
      return it if is_subset(type, internal_type(it));
    ;

    maybe_type_name = if type :: <type_ref(type_symbol(Symbol))> then just(untag(type)) else nothing;

    maybe_types = maybe_tuple_type_fields(type);
    if maybe_types != nothing:
      types = value(maybe_types);
      size = |types|;
      if size >= 2 and size <= 8:
        inter_type = :tuple((interface_type(t) : t <- types));
        inter_type = :named(value(maybe_type_name), inter_type) if maybe_type_name != nothing;
        return inter_type;
      ;
    ;

    if is_subset(type, type_seq):
      elem_type = seq_elem_supertype(type);
      return :seq(interface_type(elem_type)) if elem_type != empty_type;
    ;

    if is_subset(type, type_set):
      elem_type = set_elem_supertype(type);
      return :set(interface_type(elem_type)) if elem_type != empty_type;
    ;

    maybe_fields = maybe_record_type_fields(type);
    if maybe_fields != nothing:
      types = value(maybe_fields);
      if not (l, info <- types : info.optional):
        inter_type = :record([untag(l) -> interface_type(info.type) : l, info <- types]);
        inter_type = :named(value(maybe_type_name), inter_type) if maybe_type_name != nothing;
        return inter_type;
      ;
    ;

    if is_subset(type, type_bin_rel):
      args_types = bin_rel_args_supertypes(type);
      return :bin_rel((interface_type(t) : t <- args_types)) if args_types :: (NeType, NeType);
    ;

    if is_subset(type, type_tern_rel):
      args_types = tern_rel_args_supertypes(type);
      return :tern_rel((interface_type(t) : t <- args_types)) if args_types :: (NeType, NeType, NeType);
    ;

    if is_subset(type, type_tagged_obj):
      tag_type = tag_supertype(type);
      if is_symb_singl_type(tag_type):
        obj_type = untagged_objs_supertype(type);
        assert obj_type != empty_type; ## WHY THIS?
        if obj_type != empty_type:
          inter_type = :tagged(only_symb(tag_type), interface_type(obj_type));
          inter_type = :named(value(maybe_type_name), inter_type) if maybe_type_name != nothing;
          return inter_type;
        ;
      ;
    ;

    return :generic;
  }
}
