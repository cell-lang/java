type AtomicInterType    = bool, integer, float, symbol, string;
type BasicInterType     = AtomicInterType, generic;

type TupleInterType     = tuple(InterType+);
type RecordInterType    = record([+Symbol -> InterType]);

type TaggedInterType[T] = tagged(Symbol, T);
type TaggedInterType    = TaggedInterType[InterType];

type NameableInterType  = TupleInterType, RecordInterType, UnionInterType, TaggedInterType[NameableInterType];
type NamedInterType     = named(TypeSymbol);

type CollInterType      = seq(InterType),
                          set(InterType),
                          bin_rel(InterType, InterType),
                          tern_rel(InterType, InterType, InterType);

type SymbolInterType    = symbol(Symbol);

type UnionableInterType = TupleInterType,
                          RecordInterType,
                          TaggedInterType[UnionableInterType];

type UnionAltInterType  = SymbolInterType, TaggedInterType[UnionableInterType];
type UnionInterType     = union([+UnionAltInterType]);

type InterType          = BasicInterType,
                          SymbolInterType,
                          TupleInterType,
                          RecordInterType,
                          CollInterType,
                          TaggedInterType,
                          NamedInterType,
                          UnionInterType;

////////////////////////////////////////////////////////////////////////////////

NeType internal_type(AtomicInterType) =
  bool        = type_bool,
  integer     = integer,
  float       = float_type,
  symbol      = atom_type,
  string      = type_string;




String return_value_type(InterType it, [InterType -> String] types_names) =
  bool            = "boolean",
  integer         = "long",
  float           = "double",
  symbol          = "String",
  string          = "String",
  tuple()         |
  record()        |
  union()         = types_names(it, !!),
  named()         = lookup(types_names, it, "Value"),
  seq(t?)         |
  set(t?)         = return_value_type(t, types_names) & "[]",
  bin_rel(ts?)    = "Pair<" & append((return_value_type(t, types_names) & "[]" : t <- ts), ", ") & ">",
  tern_rel(ts?)   = "Triplet<" & append((return_value_type(t, types_names) & "[]" : t <- ts), ", ") & ">",
  tagged(_, t?)   = return_value_type(t, types_names),
  generic         = "Value";


implicit prg : CompiledPrg {
  String input_arg_type(InterType it) =
    bool            = "boolean",
    integer         = "long",
    float           = "double",
    tuple()         |
    record()        |
    union()         = input_types_names(it, !!),
    named(n?)       = lookup(input_types_names, it, "String"),
    seq(t?)         |
    set(t?)         = input_arg_type(t) & "[]",
    bin_rel(ts?)    = "Pair<" & append((input_arg_type(t) & "[]" : t <- ts), ", ") & ">",
    tern_rel(ts?)   = "Triplet<" & append((input_arg_type(t) & "[]" : t <- ts), ", ") & ">",
    tagged(_, t?)   = input_arg_type(t),
    symbol          |
    string          |
    generic         = "String";


  String return_value_type(InterType it) = return_value_type(it, output_types_names);
}

////////////////////////////////////////////////////////////////////////////////

implicit prg : CompiledPrg {
  String* import_code(InterType it, String expr, String action_prefix) =
    bool                    = (action_prefix & "SymbObj.get(" & expr & ");"),
    integer                 = (action_prefix & "IntObj.get(" & expr & ");"),
    float                   = (action_prefix & "new FloatObj(" & expr & ");"),
    symbol                  = (action_prefix & "Conversions.convertText(" & expr & ");"),
    string                  = (action_prefix & "Conversions.stringToObj(" & expr & ");"),
    symbol(s?)              = (action_prefix & "SymbObj.get(" & symb_idx_name(s) & ");"),
    tuple(ts?)              = tuple_import_code(ts, expr, action_prefix),
    record(fs?)             = record_import_code(fs, expr, action_prefix),
    named()                 = named_type_import_code(it, expr, action_prefix),
    union(ts?)              = type_union_import_code(ts, expr, action_prefix),
    seq(t?)                 = array_import_code(t, expr, action_prefix, "new MasterSeqObj"),
    set(t?)                 = array_import_code(t, expr, action_prefix, "Builder.createSet"),
    bin_rel(t1?, t2?)       = bin_rel_import_code(t1, t2, expr, action_prefix),
    tern_rel(t1?, t2?, t3?) = tern_rel_import_code(t1, t2, t3, expr, action_prefix),
    tagged(_, generic)      = import_code(:generic, expr, action_prefix),
    tagged(s?, t?)          = tagged_value_import_code(s, t, expr, action_prefix),
    generic                 = (action_prefix & "Conversions.convertText(" & expr & ");");


  String* named_type_import_code(NamedInterType inter_type, String expr, String action_prefix) =
    if in(inter_type, declared_types)
      then (action_prefix & decl_type_import_function(inter_type) & "(" & expr & ");")
      else import_code(:generic, expr, action_prefix);


  String* type_union_import_code([+UnionAltInterType] types, String expr, String action_prefix) {
    unique_id = printed(_counter_(:any_value_will_do));
    tmp_var = "var_" & unique_id;
    res_var = "res_var_" & unique_id;

    code = ("Obj " & res_var & ";");
    for t @ i <- isort(types):
      type_name = input_types_names(t, !!);
      header = (
        #(if i > 0 then "else " else "") & "if (" & expr & " instanceof " & type_name & ") {",
        "  " & type_name & " " & tmp_var & " = (" & type_name & ") " & expr & ";"
      );
      code = code & header & indent_lines(import_code(t, tmp_var, res_var & " = ")) & ("}");
    ;

    return (code | "else", "  throw Miscellanea.internalFail();", action_prefix & res_var & ";");
  }


  String* record_import_code([+Symbol -> InterType] fields, String expr, String action_prefix) {
    unique_id = printed(_counter_(:any_value_will_do));
    keys_var = "keys_" & unique_id;
    values_var = "values_" & unique_id;

    count = |fields|;

    code = (
      "Obj[] " & keys_var   & " = new Obj[" & printed(count) & "];",
      "Obj[] " & values_var & " = new Obj[" & printed(count) & "];"
    );

    field_names = java_adjusted_unambiguous_lower_camel_case_names(keys(fields));
    for l, n @ i <- isort(field_names):
      code = (code | keys_var & "[" & printed(i) & "] = " & native_expr(object(l)) & ";");
      field_expr = expr & "." & field_names(l, !!);
      asgnm_prefix = values_var & "[" & printed(i) & "] = ";
      code = code & import_code(fields(l, !!), field_expr, asgnm_prefix);
    ;

    map_creation_expr = "Builder.createMap(" & keys_var & ", " & values_var & ", " & printed(count) & ")";
    return (code | action_prefix & map_creation_expr & ";");
  }


  String* tuple_import_code(InterType+ types, String expr, String action_prefix) {
    unique_id = printed(_counter_(:any_value_will_do));
    // expr_var = "expr" & unique_id;

    field_vars = ("field" & printed(i) & "_" & unique_id : t @ i <- types);
    fields_code = (import_code(t, expr & ".item" & printed(i), "Obj " & field_vars(i) & " = ") : t @ i <- types);

    tuple_instr = action_prefix & "new MasterSeqObj(new Obj[] {" & append(field_vars, ", ") & "});";

    return (join(fields_code) | tuple_instr);
  }


  String* array_import_code(InterType elem_type, String expr, String action_prefix, String ctor) {
    unique_id = printed(_counter_(:any_value_will_do));
    expr_var = "expr" & unique_id;
    idx_var = "idx" & unique_id;
    array_var = "array" & unique_id;

    elem_code = import_code(elem_type, expr_var & "[" & idx_var & "]", array_var & "[" & idx_var & "] = ");

    return indent_lines((
        input_arg_type(elem_type) & "[] " & expr_var & " = " & expr & ";",
        "Obj[] " & array_var & " = new Obj[" & expr_var & ".length];",
        "for (int " & idx_var & " = 0 ; " & idx_var & " < " & expr_var & ".length ; " & idx_var & "++) {"
      ) & indent_lines(elem_code) & (
        "}",
        action_prefix & ctor & "(" & array_var & ");"
      )
    );
  }


  String* bin_rel_import_code(InterType arg1_type, InterType arg2_type, String expr, String action_prefix) {
    unique_id = printed(_counter_(:any_value_will_do));
    expr_var  = "expr" & unique_id;
    len_var   = "len" & unique_id;
    idx_var   = "idx" & unique_id;
    col1_var  = "col1_" & unique_id;
    col2_var  = "col2_" & unique_id;

    arg1_code = import_code(arg1_type, expr_var & ".item1[" & idx_var & "]", col1_var & "[" & idx_var & "] = ");
    arg2_code = import_code(arg2_type, expr_var & ".item2[" & idx_var & "]", col2_var & "[" & idx_var & "] = ");

    rel_type = :bin_rel(arg1_type, arg2_type); ## BAD, RECONSTRUCTING PREVIOUSLY DESTRUCTED VALUE

    return indent_lines((
        input_arg_type(rel_type) & " " & expr_var & " = " & expr & ";",
        "int " & len_var & " = " & expr_var & ".length;",
        "Obj[] " & col1_var & " = new Obj[" & len_var & "];",
        "Obj[] " & col2_var & " = new Obj[" & len_var & "];",
        "for (int " & idx_var & " = 0 ; " & idx_var & " < " & len_var & " ; " & idx_var & "++) {"
      ) & indent_lines(arg1_code & arg2_code) & (
        "}",
        action_prefix & "Builder.createBinRel(" & col1_var & ", " & col2_var & ");"
      )
    );
  }


  String* tern_rel_import_code(InterType arg1_type, InterType arg2_type, InterType arg3_type, String expr, String action_prefix) {
    unique_id = printed(_counter_(:any_value_will_do));
    expr_var  = "expr" & unique_id;
    len_var   = "len" & unique_id;
    idx_var   = "idx" & unique_id;
    col1_var  = "col1_" & unique_id;
    col2_var  = "col2_" & unique_id;
    col3_var  = "col3_" & unique_id;

    arg1_code = import_code(arg1_type, expr_var & ".item1[" & idx_var & "]", col1_var & "[" & idx_var & "] = ");
    arg2_code = import_code(arg2_type, expr_var & ".item2[" & idx_var & "]", col2_var & "[" & idx_var & "] = ");
    arg3_code = import_code(arg3_type, expr_var & ".item3[" & idx_var & "]", col3_var & "[" & idx_var & "] = ");

    rel_type = :tern_rel(arg1_type, arg2_type, arg3_type); ## BAD, RECONSTRUCTING PREVIOUSLY DESTRUCTED VALUE

    return indent_lines((
        input_arg_type(rel_type) & " " & expr_var & " = " & expr & ";",
        "int " & len_var & " = " & expr_var & ".length;",
        "Obj[] " & col1_var & " = new Obj[" & len_var & "];",
        "Obj[] " & col2_var & " = new Obj[" & len_var & "];",
        "Obj[] " & col3_var & " = new Obj[" & len_var & "];",
        "for (int " & idx_var & " = 0 ; " & idx_var & " < " & len_var & " ; " & idx_var & "++) {"
      ) & indent_lines(arg1_code & arg2_code & arg3_code) & (
        "}",
        action_prefix & "Builder.createBinRel(" & col1_var & ", " & col2_var & ", " & col3_var & ");"
      )
    );
  }


  String* tagged_value_import_code(Symbol tag, InterType inner_type, String expr, String action_prefix) {
    unique_id = printed(_counter_(:any_value_will_do));
    inner_var = "inner" & unique_id;

    inner_code = import_code(inner_type, expr, "Obj " & inner_var & " = ");
    creation_instr = action_prefix & "new TaggedObj(" & symb_idx_name(object(tag)) & ", " & inner_var & ");";

    return (inner_code | creation_instr);
  }
}


implicit prg : CompiledPrg {
  String* export_code(InterType it, String expr, String action_prefix) =
    bool                = (action_prefix & expr & ".getBool();"),
    integer             = (action_prefix & expr & ".getLong();"),
    float               = (action_prefix & expr & ".getDouble();"),
    symbol              = (action_prefix & expr & ".toString();"),
    string              = (action_prefix & expr & ".getString();"),
    symbol()            = (action_prefix & output_types_names(it, !!) & ".singleton();"),
    tuple(ts?)          = tuple_export_code(ts, output_types_names(it, !!), expr, action_prefix),
    record(fs?)         = record_export_code(fs, output_types_names(it, !!), expr, action_prefix),
    named()             = named_type_export_code(it, expr, action_prefix),
    union(ts?)          = type_union_export_code(ts, expr, action_prefix),
    seq(t?)             |
    set(t?)             = array_export_code(t, expr, action_prefix),
    bin_rel(t1?, t2?)   = bin_rel_export_code(t1, t2, expr, action_prefix),
    tern_rel(t1?, t2?, t3?) = tern_rel_export_code(t1, t2, t3, expr, action_prefix),
    tagged(_, generic)  = export_code(:generic, expr, action_prefix),
    tagged(_, t?)       = tagged_type_export_code(t, expr, action_prefix),
    generic             = (action_prefix & "Conversions.exportAsValue(" & expr & ");");


  String* tagged_type_export_code(InterType inner_type, String expr, String action_prefix) {
    unique_id = printed(_counter_(:any_value_will_do));
    tmp_var = "tmp_var_" & unique_id;
    get_inner_obj_instr = "Obj " & tmp_var & " = " & expr & ".getInnerObj();";
    return (get_inner_obj_instr) & export_code(inner_type, tmp_var, action_prefix);
  }


  String* type_union_export_code([+UnionAltInterType] types, String expr, String action_prefix) {
    unique_id = printed(_counter_(:any_value_will_do));

    symb_types = [t : t <- types, t :: SymbolInterType];
    tagged_types = [t : t <- types, t :: TaggedInterType[UnionableInterType]];
    assert symb_types & tagged_types == types;

    code = ();

    if symb_types != []:
      if |symb_types| > 1:
        symbs_code = ("switch (" & expr & ".getSymbId()) {");
        for t @ i <- isort(symb_types):
          symbs_code = (symbs_code | "case " & symb_idx_name(untag(t)) & ":");
          symbs_code = symbs_code & indent_lines(export_code(t, expr, action_prefix));
          symbs_code = (symbs_code | "  break;", "");
        ;
        symbs_code = (symbs_code | "  default:", "    throw Miscellanea.internalFail();", "}");

      else
        symbs_code = export_code(only(symb_types), expr, action_prefix);
      ;
      symbs_code = ("if (" & expr & ".isSymb()) {") & indent_lines(symbs_code) & ("}") if tagged_types != [];
      code = code & symbs_code;
    ;

    if tagged_types != []:
      if |tagged_types| > 1:
        tagged_values_code = ("switch (" & expr & ".getTagId()) {");
        for t @ i <- isort(tagged_types):
          tag = match (t) tagged(s?, _) = s;
          case_code = tagged_value_export_code(t, output_types_names(t, !!), expr, action_prefix);
          case_code = ("case " & symb_idx_name(object(tag)) & ":") & indent_lines(case_code) & ("  break;", "");
          tagged_values_code = tagged_values_code & indent_lines(case_code);
        ;
        tagged_values_code = (tagged_values_code | "  default:", "    throw Miscellanea.internalFail();", "}");

      else
        tagged_values_code = export_code(only(tagged_types), expr, action_prefix);
      ;
      if symb_types != []:
        tagged_values_code = ("else {") & indent_lines(tagged_values_code) & ("}");
      ;
      code = code & tagged_values_code;
    ;

    return code;
  }


  String* named_type_export_code(NamedInterType inter_type, String expr, String action_prefix) =
    if in(inter_type, declared_types)
      then (action_prefix & decl_type_export_function(inter_type) & "(" & expr & ");")
      else export_code(:generic, expr, action_prefix);


  String* tagged_value_export_code(TaggedInterType tagged_type, String type_name, String expr, String action_prefix) {
    untagged_expr = expr & ".getInnerObj()";
    inner_type = match (tagged_type) tagged(_, t?) = t;
    return match (inner_type)
      tuple(ts?)      = tuple_export_code(ts, type_name, untagged_expr, action_prefix),
      record(fs?)     = record_export_code(fs, type_name, untagged_expr, action_prefix),
      tagged(_, t?)   = tagged_value_export_code(inner_type, type_name, untagged_expr, action_prefix);
  }


  String* record_export_code([+Symbol -> InterType] fields, String type_name, String expr, String action_prefix) {
    unique_id = printed(_counter_(:any_value_will_do));
    record_var = "record_" & unique_id;

    field_names = java_adjusted_unambiguous_lower_camel_case_names(keys(fields));

    record_inst_instr = type_name & " " & record_var & " = new " & type_name & "();";
    asgnm_code = join(({
        asgnm_text = record_var & "." & field_names(l, !!) & " = ";
        return export_code(t, expr & ".lookupField(" & symb_idx_name(l) & ")", asgnm_text);
      } : l, t <- isort(fields)
    ));

    return (record_inst_instr) & (asgnm_code | action_prefix & record_var & ";");
  }


  String* tuple_export_code(InterType+ types, String type_name, String expr, String action_prefix) {
    unique_id = printed(_counter_(:any_value_will_do));
    tuple_var = "tuple_" & unique_id;

    tuple_instantiation_instr = type_name & " " & tuple_var & " = new " & type_name & "();";

    asgnm_code = join(({
        asgnm_text = tuple_var & ".item" & printed(i) & " = ";
        return export_code(t, expr & ".getItem(" & printed(i) & ")", asgnm_text);
      } : t @ i <- types
    ));

    return (tuple_instantiation_instr) & (asgnm_code | action_prefix & tuple_var & ";");
  }


  String* array_export_code(InterType elem_type, String expr, String action_prefix) {
    return match (elem_type)
      bool                = (action_prefix & "Conversions.toBoolArray(" & expr & ");"),
      integer             = (action_prefix & "Conversions.toLongArray(" & expr & ");"),
      float               = (action_prefix & "Conversions.toDoubleArray(" & expr & ");"),
      symbol              = (action_prefix & "Conversions.toSymbolArray(" & expr & ");"),
      string              = (action_prefix & "Conversions.toStringArray(" & expr & ");"),
      generic             = (action_prefix & "Conversions.toValueArray(" & expr & ");"),
      tagged(_, generic)  = array_export_code(:generic, expr, action_prefix),
      tuple()             |
      record()            |
      seq()               |
      set()               |
      named()             |
      tagged()            = generic_array_export_code(elem_type, expr, action_prefix);


    String* generic_array_export_code(InterType elem_type, String expr, String action_prefix) {
      unique_id = printed(_counter_(:any_value_will_do));
      expr_var = "expr" & unique_id;
      size_var = "size" & unique_id;
      array_var = "array" & unique_id;
      iter_var = "iter" & unique_id;
      idx_var = "idx" & unique_id;
      out_elem_type = return_value_type(elem_type);

      return (
        "Obj " & expr_var & " = " & expr & ";",
        "int " & size_var & " = " & expr_var & ".getSize();",
        out_elem_type & "[] " & array_var & " = new " & array_new_expr(elem_type, size_var) & ";",
        "SeqOrSetIter " & iter_var & " = " & expr_var & ".getSeqOrSetIter();",
        "int " & idx_var & " = 0;",
        "while (!" & iter_var & ".done()) {"
      ) & indent_lines(export_code(elem_type, iter_var & ".get()", array_var & "[" & idx_var & "++] = ")) & (
        "  " & iter_var & ".next();",
        "}",
        "Miscellanea._assert(" & idx_var & " == " & size_var & ");",
        action_prefix & array_var & ";"
      );
    }
  }


  String* bin_rel_export_code(InterType arg1_type, InterType arg2_type, String src_expr, String action_prefix) {
    unique_id = printed(_counter_(:any_value_will_do));
    expr_var, size_var, col1_var, col2_var, iter_var, idx_var = (
      s & "_" & unique_id : s <- ("expr", "size", "col1", "col2", "iter", "idx")
    );
    out_col1_type = return_value_type(arg1_type);
    out_col2_type = return_value_type(arg2_type);

    arg1_export_code = export_code(arg1_type, iter_var & ".get1()", col1_var & "[" & idx_var & "] = ");
    arg2_export_code = export_code(arg2_type, iter_var & ".get2()", col2_var & "[" & idx_var & "++] = ");

    return (
      "Obj " & expr_var & " = " & src_expr & ";",
      "int " & size_var & " = " & expr_var & ".getSize();",
      out_col1_type & "[] " & col1_var & " = new " & array_new_expr(arg1_type, size_var) & ";",
      out_col2_type & "[] " & col2_var & " = new " & array_new_expr(arg2_type, size_var) & ";",
      "BinRelIter " & iter_var & " = " & expr_var & ".getBinRelIter();",
      "int " & idx_var & " = 0;",
      "while (!" & iter_var & ".done()) {"
    ) & indent_lines(arg1_export_code & arg2_export_code) & (
      "  " & iter_var & ".next();",
      "}",
      "Miscellanea._assert(" & idx_var & " == " & size_var & ");",
      action_prefix & "new Pair<" & out_col1_type & "[], " & out_col2_type & "[]>(" &
        col1_var & ", " & col2_var & ");"
    );
  }


  String* tern_rel_export_code(InterType arg1_type, InterType arg2_type, InterType arg3_type, String src_expr, String action_prefix) {
    unique_id = printed(_counter_(:any_value_will_do));
    expr_var, size_var, col1_var, col2_var, col3_var, iter_var, idx_var = (
      s & "_" & unique_id : s <- ("expr", "size", "col1", "col2", "col3", "iter", "idx")
    );

    out_arg1_type = return_value_type(arg1_type);
    out_arg2_type = return_value_type(arg2_type);
    out_arg3_type = return_value_type(arg3_type);

    arg1_export_code = export_code(arg1_type, iter_var & ".get1()", col1_var & "[" & idx_var & "] = ");
    arg2_export_code = export_code(arg2_type, iter_var & ".get2()", col2_var & "[" & idx_var & "] = ");
    arg3_export_code = export_code(arg3_type, iter_var & ".get3()", col3_var & "[" & idx_var & "++] = ");

    return (
      "Obj " & expr_var & " = " & src_expr & ";",
      "int " & size_var & " = " & expr_var & ".getSize();",
      out_arg1_type & "[] " & col1_var & " = new " & array_new_expr(arg1_type, size_var) & ";",
      out_arg2_type & "[] " & col2_var & " = new " & array_new_expr(arg2_type, size_var) & ";",
      out_arg3_type & "[] " & col3_var & " = new " & array_new_expr(arg3_type, size_var) & ";",
      "TernRelIter " & iter_var & " = " & expr_var & ".getTernRelIter();",
      "int " & idx_var & " = 0;",
      "while (!" & iter_var & ".done()) {"
    ) & indent_lines(arg1_export_code & arg2_export_code & arg3_export_code) & (
      "  " & iter_var & ".next();",
      "}",
      "Miscellanea._assert(" & idx_var & " == " & size_var & ");",
      action_prefix & "new Triplet<" & out_arg1_type & "[], " & out_arg2_type & "[], " & out_arg3_type & "[]>(" &
        col1_var & ", " & col2_var & ", " & col3_var & ");"
    );
  }


  String array_new_expr(InterType elem_type, String size_expr) =
    seq(t?) | set(t?) = array_new_expr(t, size_expr) & "[]",
    _                 = return_value_type(elem_type) & "[" & size_expr & "]";
}

////////////////////////////////////////////////////////////////////////////////

implicit typedefs : [TypeName -> NeType] {
  [TypeSymbol] reachable_type_symbols([InterType] inter_types) {
    type_symbs = [ts : t <- inter_types, ts <- nested_type_symbols(t)];
    loop
      nested_type_symbs = [
        nts : ts <- type_symbs,
              t = cast_ne_type(expand_type_ref(ts, typedefs)),
              it = interface_type(t),
              nts <- nested_type_symbols(it)
      ];

      new_type_symbs = nested_type_symbs - type_symbs;
      return type_symbs if new_type_symbs == [];
      type_symbs = type_symbs & new_type_symbs;
    ;
  }


  NeType expand_top_level_type_refs(NeType type) =
    symb_type()         |
    atom_type           |
    integer             |
    low_ints()          |
    high_ints()         |
    int_range()         |
    float_type          |
    empty_seq_type      |
    empty_rel_type      |
    type_var()          |
    ne_seq_type()       |
    ne_set_type()       |
    ne_map_type()       |
    ne_bin_rel_type()   |
    ne_tern_rel_type()  |
    ne_record_type()    |
    tuple_type()        |
    tag_obj_type()      = type,
    type_ref(ts?)       = expand_top_level_type_refs(cast_ne_type(expand_type_ref(ts, typedefs))),
    union_type(ts?)     = ne_union_type([expand_top_level_type_refs(t) : t <- ts]);


  InterType interface_type(NeType type) {
    for it <- (:bool, :integer, :float, :string):
      return it if is_subset(type, internal_type(it));
    ;

    maybe_types = maybe_tuple_type_fields(type);
    if maybe_types != nothing:
      types = value(maybe_types);
      size = |types|;
      if size >= 2 and size <= 8:
        return if type :: TypeRef
          then :named(match (type) type_ref(ts?) = ts)
          else :tuple((interface_type(t) : t <- types));
      ;
    ;

    if is_subset(type, type_seq):
      elem_type = seq_elem_supertype(type);
      return :seq(interface_type(elem_type)) if elem_type != empty_type;
    ;

    if is_subset(type, type_set):
      elem_type = set_elem_supertype(type);
      return :set(interface_type(elem_type)) if elem_type != empty_type;
    ;

    maybe_fields = maybe_record_type_fields(type);
    if maybe_fields != nothing:
      types = value(maybe_fields);
      if not (l, info <- types : info.optional):
        return if type :: TypeRef
          then :named(match (type) type_ref(ts?) = ts)
          else :record([untag(l) -> interface_type(info.type) : l, info <- types]);
      ;
    ;

    if is_subset(type, type_bin_rel):
      args_types = bin_rel_args_supertypes(type);
      return :bin_rel((interface_type(t) : t <- args_types)) if args_types :: (NeType, NeType);
    ;

    if is_subset(type, type_tern_rel):
      args_types = tern_rel_args_supertypes(type);
      return :tern_rel((interface_type(t) : t <- args_types)) if args_types :: (NeType, NeType, NeType);
    ;

    if is_subset(type, type_tagged_obj):
      tag_type = tag_supertype(type);
      if is_symb_singl_type(tag_type):
        obj_type = untagged_objs_supertype(type);
        assert obj_type != empty_type; ## WHY THIS?
        if obj_type != empty_type:
          return if type :: TypeRef
            then :named(match (type) type_ref(ts?) = ts)
            else :tagged(untag(only_symb(tag_type)), interface_type(obj_type));
        ;
      ;
    ;

    if type :: UnionType:
      maybe_union_inter_type = union_intertype(match (type) union_type(ts?) = ts);
      return value(maybe_union_inter_type) if maybe_union_inter_type != nothing;
    ;

    return :symbol if is_subset(type, internal_type(:symbol));

    return :named(match (type) type_ref(ts?) = ts) if type :: TypeRef;

    return :generic;
  }


  Maybe[UnionInterType] union_intertype([+NeType] types) {
    inter_types = [
      if is_symb_singl_type(t)
        then :symbol(untag(only_symb(t)))
        else interface_type(t)
      : t <- types
    ];

    return if inter_types :: [+UnionAltInterType]
      then just(:union(inter_types))
      else nothing;
  }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

[TypeSymbol] nested_type_symbols(InterType inter_type) =
  bool            |
  integer         |
  float           |
  symbol          |
  string          |
  generic         |
  symbol()        = [],
  tuple(ts?)      = [s : t <~ ts, s <- nested_type_symbols(t)],
  record(fs?)     = [s : unused_var, t <- fs, s <- nested_type_symbols(t)],
  union(ts?)      = [s : t <- ts, s <- nested_type_symbols(t)],
  named(s?)       = [s],
  tagged(_, t?)   |
  seq(t?)         |
  set(t?)         = nested_type_symbols(t),
  bin_rel(ts?)    |
  tern_rel(ts?)   = [s : t <~ ts, s <- nested_type_symbols(t)];
