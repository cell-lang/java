type AtomicInterType  = bool, integer, float, symbol, string;
type BasicInterType   = AtomicInterType, generic;

type TupleInterType   = tuple(InterType+);
type RecordInterType  = record([+Symbol -> InterType]);
type TaggedInterType  = tagged(SymbObj, InterType);

type NamedInterType   = named(type_symbol(Atom), <TupleInterType, RecordInterType, TaggedInterType>);

type InterType        = BasicInterType,
                        TupleInterType,
                        RecordInterType,
                        seq(InterType),
                        set(InterType),
                        TaggedInterType,
                        NamedInterType;


NeType internal_type(AtomicInterType) =
  bool        = type_bool,
  integer     = integer,
  float       = float_type,
  symbol      = atom_type,
  string      = type_string;

implicit decl_types : [InterType -> String] {
  String input_arg_type(InterType it) =
    bool            = "boolean",
    integer         = "long",
    float           = "double",
    tuple()         |
    record()        = decl_types(it, !!),
    named(n?, t?)   = if decl_types(t, *) then decl_types(t, !!) else return_value_type(t),
    seq(t?)         |
    set(t?)         = input_arg_type(t) & "[]",
    tagged(_, t?)   = input_arg_type(t),
    symbol          |
    string          |
    generic         = "String";


  String* import_code(InterType it, String expr, String action_prefix) =
    bool                = (action_prefix & "SymbObj.get(" & expr & ");"),
    integer             = (action_prefix & "IntObj.get(" & expr & ");"),
    float               = (action_prefix & "new FloatObj(" & expr & ");"),
    symbol              = (action_prefix & "Conversions.convertText(" & expr & ");"),
    string              = (action_prefix & "Conversions.stringToObj(" & expr & ");"),
    tuple(ts?)          = tuple_import_code(ts, expr, action_prefix),
    record(fs?)         = record_import_code(fs, expr, action_prefix),
    named()             = (), ## IMPLEMENT IMPLEMENT IMPLEMENT
    seq(t?)             = array_import_code(t, expr, action_prefix, "new MasterSeqObj"),
    set(t?)             = array_import_code(t, expr, action_prefix, "Builder.createSet"),
    tagged(_, generic)  = import_code(:generic, expr, action_prefix),
    tagged(s?, t?)      = tagged_value_import_code(s, t, expr, action_prefix),
    generic             = (action_prefix & "Conversions.convertText(" & expr & ");");


  String* record_import_code([+Symbol -> InterType] fields, String expr, String action_prefix) {
    ## IMPLEMENT IMPLEMENT IMPLEMENT
    return ();
  }


  String* tuple_import_code(InterType+ types, String expr, String action_prefix) {
    unique_id = printed(_counter_(:any_value_will_do));
    expr_var = "expr" & unique_id;

    field_vars = ("field" & printed(i) & "_" & unique_id : t @ i <- types);
    fields_code = (import_code(t, expr_var & ".item" & printed(i), "Obj " & field_vars(i) & " = ") : t @ i <- types);

    tuple_instr = action_prefix & "new MasterSeqObj(new Obj[] {" & append(field_vars, ", ") & "});";

    ## BAD, I'M RECONSTRUCTING THE InterType VALUE AFTER DESTROYING IT
    return (input_arg_type(:tuple(types)) & " " & expr_var & " = " & expr & ";") &
           (join(fields_code) | tuple_instr);
  }


  String* array_import_code(InterType elem_type, String expr, String action_prefix, String ctor) {
    unique_id = printed(_counter_(:any_value_will_do));
    expr_var = "expr" & unique_id;
    idx_var = "idx" & unique_id;
    array_var = "array" & unique_id;

    elem_code = import_code(elem_type, expr_var & "[" & idx_var & "]", array_var & "[" & idx_var & "] = ");

    return indent_lines((
        input_arg_type(elem_type) & "[] " & expr_var & " = " & expr & ";",
        "Obj[] " & array_var & " = new Obj[" & expr_var & ".length];",
        "for (int " & idx_var & " = 0 ; " & idx_var & " < " & expr_var & ".length ; " & idx_var & "++) {"
      ) & indent_lines(elem_code) & (
        "}",
        action_prefix & ctor & "(" & array_var & ");"
      )
    );
  }


  String* tagged_value_import_code(SymbObj tag, InterType inner_type, String expr, String action_prefix) {
    unique_id = printed(_counter_(:any_value_will_do));
    inner_var = "inner" & unique_id;

    inner_code = import_code(inner_type, expr, "Obj " & inner_var & " = ");
    creation_instr = action_prefix & "new TaggedObj(" & symb_idx_name(tag) & ", " & inner_var & ");";

    return (inner_code | creation_instr);
  }


  String return_value_type(InterType it) =
    bool          = "boolean",
    integer       = "long",
    float         = "double",
    symbol        = "String",
    string        = "String",
    tuple()       |
    record()      = decl_types(it, !!),
    named(n?, t?) = if decl_types(t, *) then decl_types(t, !!) else return_value_type(t),
    seq(t?)       |
    set(t?)       = return_value_type(t) & "[]",
    tagged(_, t?) = if t != :generic then return_value_type(t) else return_value_type(:generic),
    generic       = "Value";


  String* export_code(InterType it, String expr, String action_prefix) =
    bool                = (action_prefix & expr & ".getBool();"),
    integer             = (action_prefix & expr & ".getLong();"),
    float               = (action_prefix & expr & ".getDouble();"),
    symbol              = (action_prefix & expr & ".toString();"),
    string              = (action_prefix & expr & ".getString();"),
    tuple(ts?)          = tuple_export_code(ts, expr, action_prefix),
    record(fs?)         = record_export_code(fs, expr, action_prefix),
    named()             = (), ## IMPLEMENT IMPLEMENT IMPLEMENT
    seq(t?)             |
    set(t?)             = array_export_code(t, expr, action_prefix),
    tagged(_, generic)  = export_code(:generic, expr, action_prefix),
    tagged(_, t?)       = export_code(t, expr & ".getInnerObj()", action_prefix),
    generic             = (action_prefix & "Conversions.exportAsValue(" & expr & ");");


  String* record_export_code([+Symbol -> InterType] fields, String expr, String action_prefix) {
    ## IMPLEMENT IMPLEMENT IMPLEMENT
    return ();
  }


  String* tuple_export_code(InterType+ types, String expr, String action_prefix) {
    unique_id = printed(_counter_(:any_value_will_do));
    // expr_var = "expr" & unique_id;
    tuple_var = "tuple" & unique_id;

    tuple_type = decl_types(:tuple(types), !!); //## BAD, RECONSTRUCTING TUPLE TYPE
    tuple_instantiation_instr = tuple_type & " " & tuple_var & " = new " & tuple_type & "();";

    asgnm_code = join(({
        asgnm_text = tuple_var & ".item" & printed(i) & " = ";
        return export_code(t, expr & ".getItem(" & printed(i) & ")", asgnm_text);
      } : t @ i <- types
    ));

    return (tuple_instantiation_instr) & (asgnm_code | action_prefix & tuple_var & ";");
  }


  String* array_export_code(InterType elem_type, String expr, String action_prefix) {
    return match (elem_type)
      bool                = (action_prefix & "Conversions.toBoolArray(" & expr & ");"),
      integer             = (action_prefix & "Conversions.toLongArray(" & expr & ");"),
      float               = (action_prefix & "Conversions.toDoubleArray(" & expr & ");"),
      symbol              = (action_prefix & "Conversions.toSymbolArray(" & expr & ");"),
      string              = (action_prefix & "Conversions.toStringArray(" & expr & ");"),
      generic             = (action_prefix & "Conversions.toValueArray(" & expr & ");"),
      tagged(_, generic)  = array_export_code(:generic, expr, action_prefix),
      tuple()             |
      record()            |
      seq()               |
      set()               |
      tagged()            = generic_array_export_code(elem_type, expr, action_prefix);


    String* generic_array_export_code(InterType elem_type, String expr, String action_prefix) {
      unique_id = printed(_counter_(:any_value_will_do));
      expr_var = "expr" & unique_id;
      size_var = "size" & unique_id;
      array_var = "array" & unique_id;
      iter_var = "iter" & unique_id;
      idx_var = "idx" & unique_id;
      out_elem_type = return_value_type(elem_type);

      return (
        "Obj " & expr_var & " = " & expr & ";",
        "int " & size_var & " = " & expr_var & ".getSize();",
        out_elem_type & "[] " & array_var & " = new " & array_new_expr(elem_type, size_var) & ";",
        "SeqOrSetIter " & iter_var & " = " & expr_var & ".getSeqOrSetIter();",
        "int " & idx_var & " = 0;",
        "while (!" & iter_var & ".done()) {"
      ) & indent_lines(export_code(elem_type, iter_var & ".get()", array_var & "[" & idx_var & "++] = ")) & (
        "  " & iter_var & ".next();",
        "}",
        "Miscellanea._assert(" & idx_var & " == " & size_var & ");",
        action_prefix & array_var & ";"
      );
    }
  }


  String array_new_expr(InterType elem_type, String size_expr) =
    seq(t?) | set(t?) = array_new_expr(t, size_expr) & "[]",
    _                 = return_value_type(elem_type) & "[" & size_expr & "]";
}

////////////////////////////////////////////////////////////////////////////////

implicit typedefs : [TypeName -> NeType] {
  InterType interface_type(NeType type) {
    for it <- (:bool, :integer, :float, :symbol, :string):
      return it if is_subset(type, internal_type(it));
    ;

    maybe_types = maybe_tuple_type_fields(type);
    if maybe_types != nothing:
      types = value(maybe_types);
      size = |types|;
      return :tuple((interface_type(t) : t <- types)) if size >= 2 and size <= 6;
    ;

    if is_subset(type, type_seq):
      elem_type = seq_elem_supertype(type);
      return :seq(interface_type(elem_type)) if elem_type != empty_type;
    ;

    if is_subset(type, type_set):
      elem_type = set_elem_supertype(type);
      return :set(interface_type(elem_type)) if elem_type != empty_type;
    ;

    maybe_type_name = if type :: <type_ref(type_symbol(Symbol))> then just(untag(type)) else nothing;

    maybe_fields = maybe_record_type_fields(type);
    if maybe_fields != nothing:
      types = value(maybe_fields);
      if not (l, info <- types : info.optional):
        inter_type = :record([untag(l) -> interface_type(info.type) : l, info <- types]);
        inter_type = :named(value(maybe_type_name), inter_type) if maybe_type_name != nothing;
        return inter_type;
      ;
    ;

    if is_subset(type, type_tagged_obj):
      tag_type = tag_supertype(type);
      if is_symb_singl_type(tag_type):
        obj_type = untagged_objs_supertype(type);
        assert obj_type != empty_type; ## WHY THIS?
        if obj_type != empty_type:
          inter_type = :tagged(only_symb(tag_type), interface_type(obj_type));
          inter_type = :named(value(maybe_type_name), inter_type) if maybe_type_name != nothing;
          return inter_type;
        ;
      ;
    ;

    return :generic;


  }

}
