implicit prg : CompiledPrg, block_name : DBSymbol, root_block_name : DBSymbol {
  String external_name(MethodSymbol member) = sentence_case(bare_id(member));

  String pretty_name(MethodSymbol member) = safe_lower_camel_case(bare_id(member));

  String path_prefix = "automaton.";

  String db_class_name = safe_class_name(root_block_name);
}


implicit prg : CompiledPrg, block_name : DBSymbol, root_block_name : DBSymbol, duplicate_names : [String, Nat] {

  String call_method_name(MethodId method_id) =
    if pretty_name_has_conflicts(method_id.symbol, method_id.arity)
      then "_" & external_name(method_id.symbol) // Fallback name
      else pretty_name(method_id.symbol);


  Bool pretty_name_has_conflicts(MethodSymbol member, Nat arity) {
    pretty_name = pretty_name(member);
    builtin_methods = builtin_methods;
    return pretty_name == db_class_name or
           builtin_methods(pretty_name, arity) or
           duplicate_names(pretty_name, arity);

    [String, Nat] builtin_methods = [
      // Object class constructor
      "Object",           0;

      // Object class instance methods
      "equals",           1;
      "finalize",         0;
      "hashCode",         0;
      "getClass",         0;
      "clone",            0;
      "toString",         0;
      "notify",           0;
      "notifyAll",        0;
      "wait",             0;
      "wait",             1;
      "wait",             2;

      // Always present methods
      "load",             1;
      "save",             1;
      "execute",          1
    ];
  }
}


implicit
  prg             : CompiledPrg,
  typedefs        : [TypeName -> NeType], ## REMOVE IT IF POSSIBLE. IT'S REDUNDANT
  block_name      : DBSymbol,
  root_block_name : DBSymbol,
  duplicate_names : [String, Nat] {

  ## WHAT'S THAT is_gen_memb_tester? WHY IS IT false WITH ACCESSORS?
  (String*, String*) db_method_wrapper(MethodId method_id, <CompiledMethod, OptCompMethod> method, Bool is_gen_memb_tester) {
    if not method_id.id? {
      ext_name = call_method_name(method_id);
      return method_wrapper(method_id, method, block_name, ext_name, db_class_name, path_prefix, is_gen_memb_tester);
    }
    else {
      return ((), ());
    }
  }

  //////////////////////////////////////////////////////////////////////////////

  (String*, String*) static_auto_accessors(StaticBlock block, [DBSymbol -> StaticBlock] blocks, [MethodId] gen_memb_testers_ids) {
    methods_wrappers = isort([db_method_wrapper(id, m, gen_memb_testers_ids(id)) : id, m <- block.methods]);
    methods_wrappers_code, methods_wrappers_docs = (join(ls) : ls <- unzip(methods_wrappers));
    methods_wrappers_docs = ("") & methods_wrappers_docs if methods_wrappers_docs != ();

    ## THIS PART OF THE CODE IS USELESS NOW, SINCE THE accessors FIELD IS NOT USED ANYMORE
    accessors_wrappers = isort([db_method_wrapper(id, m, false) : id, m <- block.accessors]);
    accessors_wrappers_code, accessors_wrappers_docs = (join(ls) : ls <- unzip(accessors_wrappers));
    accessors_wrappers_docs = ("") & accessors_wrappers_docs if accessors_wrappers_docs != ();

    code = methods_wrappers_code & accessors_wrappers_code;

    docs_by_type = (methods_wrappers_docs, accessors_wrappers_docs);
    docs = join((indent_lines(d) : d <- docs_by_type));

    return (code, docs);
  }
}

////////////////////////////////////////////////////////////////////////////////

implicit prg : CompiledPrg, block_name : DBSymbol, root_block_name : DBSymbol {
  (String, Nat)* pretty_names(StaticBlock block, [DBSymbol -> StaticBlock] blocks) {
    methods_names = (
      (pretty_name(id.symbol), id.arity) : id, unused_var <- isort(block.methods), not id.id?
    );
    accessors_names = ((pretty_name(id.symbol), id.arity) : id, unused_var <- isort(block.accessors));
    return methods_names & accessors_names;
  }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

[NeType] interface_types(StaticBlock root_block, [DBSymbol -> StaticBlock] blocks) {
  methods_types = union([set(m.args_types) & [m.ret_type] : unused_var, m <- root_block.methods]);
  accessors_types = union([set(a.args_types) & [a.ret_type] : unused_var, a <- root_block.accessors]);
  return methods_types & accessors_types;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

implicit prg : CompiledPrg, typedefs : [TypeName -> NeType] {
  (String, String*, String*) static_auto_wrapper(StaticBlock root_block, [DBSymbol -> StaticBlock] blocks, [MethodId] gen_memb_testers_ids) {
    let block_name = root_block.name, root_block_name = root_block.name {
      dup_names = [id(0), id(1) : id <- duplicates(pretty_names(root_block, blocks))];
      let duplicate_names = dup_names {
        accessors_code, accessors_docs = static_auto_accessors(root_block, blocks, gen_memb_testers_ids);
        class_name = db_class_name;
      }
    }

    db_name = native_name(root_block.name);
    updater_name = native_updater_name(root_block.name);
    has_any_updates = root_block.msg_memb_pred != nothing;

    links_types = (upper_camel_case(bare_id(l)) : l <- root_block.links);

    ctor_impl_args = (t & " d" & printed(i) : t @ i <- links_types);

    dep_autos_args_list = append(("d" & printed(i) & ".automaton, " : i < |links_types|));
    dep_updaters_args_list = append(("d" & printed(i) & ".updater" : i < |links_types|), ", ");

    dep_autos_list = append(("dependee" & printed(i) & ".automaton, " : i < |links_types|));
    dep_updaters_list = append(("dependee" & printed(i) & ".updater" : i < |links_types|), ", ");

    class_impl = (
      "package net.cell_lang;",
      "",
      "import java.io.IOException;",
      "import java.io.Reader;",
      "import java.io.Writer;",
      "import java.io.BufferedWriter;",
      "",
      "",
      "public class " & class_name & " {",
      "  Generated.Env env;",
      "  Generated." & db_name & " automaton;",
      "  Generated." & updater_name & " updater;"
    );

    for rel_auto_id @ i <- root_block.links {
      dep_decl = "  " & safe_class_name(rel_auto_id) & " dependee" & _print_(i) & ";";
      class_impl = (class_impl | dep_decl);
    }

    class_impl = (class_impl |
      "",
      "  public " & class_name & "(" & append(ctor_impl_args, ", ") & ") {",
      "    env = new Generated.Env();",
      "    automaton = new Generated." & db_name & "(" & dep_autos_args_list & "env);",
      "    updater = automaton.newUpdater(" & dep_updaters_args_list & ");"
    );

    for rel_auto_id @ i <- root_block.links {
      idx_str = _print_(i);
      class_impl = (class_impl | "    dependee" & idx_str & " = d" & idx_str & ";");
    }

    class_impl = (class_impl |
      "  }",
      "",
      "  public void save(Writer writer) {",
      "    if (!(writer instanceof BufferedWriter))",
      "      writer = new BufferedWriter(writer);",
      "    try {",
      "      " & native_method_call("automaton", write_state_proc_name(root_block.name), ("writer")),
      "    }",
      "    catch(IOException e) {",
      "      throw new RuntimeException(e);",
      "    }",
      "  }",
      "",
      "  public void load(Reader reader) {",
      "    try {",
      "      Generated." & db_name & " newAutomaton = new Generated." & db_name & "(" & dep_autos_list & "reader, env);",
      "      Generated." & updater_name & " newUpdater = newAutomaton.newUpdater(" & dep_updaters_list & ");",
      "",
      "      automaton = newAutomaton;",
      "      updater = newUpdater;",
      "    }",
      "    catch(IOException e) {",
      "      throw new RuntimeException(e);",
      "    }",
      "  }"
    );

    if has_any_updates {
      class_impl = class_impl & (
        "",
        "  public void execute(String text) {",
        "    Obj msg = Conversions.convertText(text);",
        "    if (!Generated." & native_fn_name(value_unsafe(root_block.msg_memb_pred)) & "(msg))",
        "      throw new RuntimeException(\"Invalid message\");",
        "    boolean " & native_method_call("ok", "automaton", update_entry_point_name(root_block.name), ("msg", "updater", "env")),
        "    if (!ok) {",
        "      env = new Generated.Env();",
        "      throw new RuntimeException(\"Update failed\");",
        "    }",
        "  }"
      );
    }

    class_impl = class_impl & indent_lines(accessors_code) & ("}") ;

    class_docs = (
      "class " & class_name & " {",
      "  " & class_name & "(" & append(ctor_impl_args, ", ") & ");",
      "",
      "  void load(Reader);",
      "  void save(Writer);"
    );
    class_docs = (class_docs | "", "  void execute(String);") if has_any_updates;
    class_docs = class_docs & accessors_docs if accessors_docs != ();
    class_docs = (class_docs | "}");

    return (class_name, class_impl, class_docs);
  }
}
