implicit prg : CompiledPrg, block_name : DBSymbol, db_var_chain : NestedDBVar*, root_block_name : DBSymbol {
  String external_name(MethodSymbol member) =
    append((sentence_case(bare_id(x)) : x <- (db_var_chain | member)), "_");

  String pretty_name(MethodSymbol member) =
    safe_lower_camel_case_chain((bare_id(x) : x <- (db_var_chain | member)));

  String path_prefix = "automaton." & append((native_var_decl_name(v) & "." : v <- db_var_chain));

  String db_class_name = safe_class_name(root_block_name);
}


implicit prg : CompiledPrg, block_name : DBSymbol, db_var_chain : NestedDBVar*,
         root_block_name : DBSymbol, duplicate_names : [String, Nat] {

  String call_method_name(MethodId method_id) =
    if pretty_name_has_conflicts(method_id.symbol, method_id.arity)
      then "_" & external_name(method_id.symbol) // Fallback name
      else pretty_name(method_id.symbol);


  Bool pretty_name_has_conflicts(MethodSymbol member, Nat arity) {
    pretty_name = pretty_name(member);
    builtin_methods = builtin_methods;
    return pretty_name == db_class_name or
           builtin_methods(pretty_name, arity) or
           duplicate_names(pretty_name, arity);

    [String, Nat] builtin_methods = [
      // Object class constructor
      "Object",           0;

      // Object class instance methods
      "equals",           1;
      "finalize",         0;
      "hashCode",         0;
      "getClass",         0;
      "clone",            0;
      "toString",         0;
      "notify",           0;
      "notifyAll",        0;
      "wait",             0;
      "wait",             1;
      "wait",             2;

      // Always present methods
      "readState",        0;
      "setState",         1;
      "execute",          1
    ];
  }
}


implicit
  prg             : CompiledPrg,
  typedefs        : [TypeName -> NeType], ## REMOVE IT IF POSSIBLE. IT'S REDUNDANT
  block_name      : DBSymbol,
  db_var_chain    : NestedDBVar*,
  root_block_name : DBSymbol,
  duplicate_names : [String, Nat] {

  (String*, String*) db_method_wrapper(MethodId method_id, CompiledMethod method) {
    if not method_id.id?:
      ext_name = call_method_name(method_id);
      return method_wrapper(method_id, method, block_name, ext_name, db_class_name, path_prefix);
    else
      return ((), ());
    ;
  }

  //////////////////////////////////////////////////////////////////////////////

  (String*, String*) static_auto_accessors(StaticBlock block, [DBSymbol -> StaticBlock] blocks) {
    methods_wrappers = isort([db_method_wrapper(id, m) : id, m <- block.methods]);
    methods_wrappers_code, methods_wrappers_docs = (join(ls) : ls <- unzip(methods_wrappers));
    methods_wrappers_docs = ("") & methods_wrappers_docs if methods_wrappers_docs != ();

    accessors_wrappers = isort([db_method_wrapper(id, m) : id, m <- block.accessors]);
    accessors_wrappers_code, accessors_wrappers_docs = (join(ls) : ls <- unzip(accessors_wrappers));
    accessors_wrappers_docs = ("") & accessors_wrappers_docs if accessors_wrappers_docs != ();

    nested_autos_accessors = isort([
        static_auto_accessors(blocks[t], blocks, block_name = blocks[t].name, db_var_chain = (db_var_chain | v))
      : v, t <- block.nested_blocks
    ]);
    nested_autos_code, nested_autos_docs = (join(ls) : ls <- unzip(nested_autos_accessors));

    code = methods_wrappers_code & accessors_wrappers_code & nested_autos_code;

    docs_by_type = (methods_wrappers_docs, accessors_wrappers_docs);
    docs = join((indent_lines(d) : d <- docs_by_type)) & nested_autos_docs;

    return (code, docs);
  }
}

////////////////////////////////////////////////////////////////////////////////

implicit prg : CompiledPrg, block_name : DBSymbol, db_var_chain : NestedDBVar*, root_block_name : DBSymbol {
  (String, Nat)* pretty_names(StaticBlock block, [DBSymbol -> StaticBlock] blocks) {
    methods_names = (
      (pretty_name(id.symbol), id.arity) : id, unused_var <- isort(block.methods), not id.id?
    );
    accessors_names = ((pretty_name(id.symbol), id.arity) : id, unused_var <- isort(block.accessors));
    nested_names = join((
      pretty_names(blocks(b, !!), blocks, block_name = b, db_var_chain = (db_var_chain | v))
      : v, b <- isort(block.nested_blocks))
    );
    return methods_names & accessors_names & nested_names;
  }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

[NeType] interface_types(StaticBlock root_block, [DBSymbol -> StaticBlock] blocks) {
  methods_types = union([set(m.args_types) & [m.ret_type] : unused_var, m <- root_block.methods]);
  accessors_types = union([set(a.args_types) & [a.ret_type] : unused_var, a <- root_block.accessors]);
  nested_autos_types = union([interface_types(blocks(b, !!), blocks) : v, b <- root_block.nested_blocks]);
  return methods_types & accessors_types & nested_autos_types;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

implicit prg : CompiledPrg, typedefs : [TypeName -> NeType] {
  (String, String*, String*) static_auto_wrapper(StaticBlock root_block, [DBSymbol -> StaticBlock] blocks) {
    let block_name = root_block.name, db_var_chain = (), root_block_name = root_block.name:
      dup_names = [id(0), id(1) : id <- duplicates(pretty_names(root_block, blocks))];
      let duplicate_names = dup_names:
        accessors_code, accessors_docs = static_auto_accessors(root_block, blocks);
        class_name = db_class_name;
      ;
    ;

    db_name = native_name(root_block.name);
    updater_name = aux_struct_c_name(root_block.name);
    has_any_updates = root_block.msg_memb_pred != nothing;

    links_types = (upper_camel_case(bare_id(l)) : l <- root_block.links);

    ctor_impl_args = (t & " l" & printed(i) : t @ i <- links_types);

    class_impl = (
      "package net.cell_lang;",
      "",
      "",
      "public class " & class_name & " {",
      "  Generated.Env env;",
      "  Generated." & db_name & " automaton;",
      "  Generated." & updater_name & " updater;",
      "",
      "  public " & class_name & "(" & append(ctor_impl_args, ", ") & ") {",
      "    env = new Generated.Env();",
      "    automaton = new Generated." & db_name & "(env);",
      "    updater = automaton.newUpdater();",
      "  }",
      "",
      "  public net.cell_lang.Value readState() {",
      "    Obj " & native_method_call("obj", "automaton", copy_state_proc_name(root_block.name), ()),
      "    return Conversions.exportAsValue(obj);",
      "  }",
      "",
      "  public void setState(String text) {",
      "    Obj obj = Conversions.convertText(text);",
      "    Generated." & db_name & " instance = Generated." & db_name & ".reconstruct(obj, env);",
      "    if (instance == null)",
      "      throw new RuntimeException(\"Invalid state\");",
      "    automaton = instance;",
      "    updater = automaton.newUpdater();",
      "  }"
    );

    if has_any_updates:
      class_impl = class_impl & (
        "",
        "  public void execute(String text) {",
        "    Obj msg = Conversions.convertText(text);",
        "    if (!Generated." & native_fn_name(value_unsafe(root_block.msg_memb_pred)) & "(msg))",
        "      throw new RuntimeException(\"Invalid message\");",
        "    boolean " & native_method_call("ok", "automaton", update_entry_point_name(root_block.name), ("msg", "updater", "env")),
        "    if (!ok) {",
        "      env = new Generated.Env();",
        "      throw new RuntimeException(\"Update failed\");",
        "    }",
        "  }"
      );
    ;

    class_impl = class_impl & indent_lines(accessors_code) & ("}") ;

    class_docs = (
      "class " & class_name & " {",
      "  " & class_name & "(" & append(ctor_impl_args, ", ") & ");",
      "",
      "  Value readState();",
      "  void setState(String);",
      "  void execute(String);" if has_any_updates
    );
    class_docs = class_docs & accessors_docs if accessors_docs != ();
    class_docs = (class_docs | "}");

    return (class_name, class_impl, class_docs);
  }
}
