type AtomicInterType    = bool, integer, float, string;
type BasicInterType     = AtomicInterType, generic;

type TupleInterType     = tuple(InterType+);
type RecordInterType    = record([+Symbol -> InterType]);

type TaggedInterType[T] = tagged(Symbol, T);
type TaggedInterType    = TaggedInterType[InterType];

type NamedInterType     = named(TypeSymbol);

type CollInterType      = seq(InterType),
                          set(InterType);

type SymbolInterType    = symbol(Symbol);

type UnionAltInterType  = SymbolInterType, TaggedInterType, NamedInterType;
type UnionInterType     = union([+UnionAltInterType]);

type InterType          = BasicInterType,
                          SymbolInterType,
                          TupleInterType,
                          RecordInterType,
                          CollInterType,
                          TaggedInterType,
                          NamedInterType,
                          UnionInterType;

////////////////////////////////////////////////////////////////////////////////

type DeclInterType  = SymbolInterType, TupleInterType, RecordInterType, NamedInterType,
                      UnionInterType, TaggedInterType;

////////////////////////////////////////////////////////////////////////////////

Symbol symbol(SymbolInterType)  = symbol(s?) = s;

InterType+ field_types(TupleInterType)  = tuple(ts?) = ts;

[+Symbol -> InterType] fields(RecordInterType) = record(fs?) = fs;

Symbol type_tag(TaggedInterType)          = tagged(s?, _) = s;
T      untagged_type(TaggedInterType[T])  = tagged(_, t?) = t;

TypeSymbol type_symb(NamedInterType)  = named(ts?) = ts;

[+UnionAltInterType] inter_types(UnionInterType) = union(ts?) = ts;

////////////////////////////////////////////////////////////////////////////////

[Symbol] symbols(DeclInterType inter_type, (NamedInterType -> DeclInterType) inter_type_def) =
  symbol(s?)  = [s],
  named()     = symbols(inter_type_def(inter_type), inter_type_def),
  union(ts?)  = [s : t <- ts, s <- symbols(t, inter_type_def)],
  tuple()     |
  record()    |
  tagged()    = [];


[Symbol] tags(DeclInterType inter_type, (NamedInterType -> DeclInterType) inter_type_def) =
  tagged(s?, _) = [s],
  named()       = tags(inter_type_def(inter_type), inter_type_def),
  union(ts?)    = [s : t <- ts, s <- tags(t, inter_type_def)],
  symbol()      |
  tuple()       |
  record()      = [];

////////////////////////////////////////////////////////////////////////////////

NeType internal_type(AtomicInterType) =
  bool        = type_bool,
  integer     = integer,
  float       = float_type,
  string      = type_string;


implicit prg : CompiledPrg {
  String input_arg_type(InterType it) {
    if in(it, declared_types):
      fail if not it :: DeclInterType; ## BAD
      return input_types_names(it, !!) if not is_simplifiable(it);
    ;

    return match (it)
      bool            = "boolean",
      integer         = "long",
      float           = "double",
      symbol()        |
      tuple()         |
      record()        |
      union()         = undefined,
      named(n?)       = input_arg_type(named_interface_types_defs(it, !!)),
      seq(t?)         |
      set(t?)         = input_arg_type(t) & "[]",
      tagged(_, t?)   = input_arg_type(t),
      string          |
      generic         = "String";
  }


  String return_value_type(InterType it) = return_value_type(it, output_types_names);


  String return_value_type(InterType it, [DeclInterType -> String] types_names) {
    if in(it, declared_types):
      fail if not it :: DeclInterType; ## BAD
      return types_names(it, !!) if not is_simplifiable(it);
    ;

    return match (it)
      bool            = "boolean",
      integer         = "long",
      float           = "double",
      string          = "String",
      symbol()        |
      tuple()         |
      record()        |
      union()         = undefined,
      named()         = return_value_type(named_interface_types_defs(it, !!), types_names),
      seq(t?)         |
      set(t?)         = return_value_type(t, types_names) & "[]",
      tagged(_, t?)   = return_value_type(t, types_names),
      generic         = "Value";
  }
}

////////////////////////////////////////////////////////////////////////////////

implicit prg : CompiledPrg {
  String* import_code(InterType it, String expr, String action_prefix) =
    import_code_ex(it, expr, action_prefix, treat_generic_as_value = false);
}


implicit prg : CompiledPrg, treat_generic_as_value : Bool {
  String* decl_type_import_code(SymbolInterType inter_type, String expr, String action_prefix) {
    return (action_prefix & "SymbObj.get(" & symb_idx_name(symbol(inter_type)) & ");");

  }

  String* decl_type_import_code(TupleInterType inter_type, String expr, String action_prefix) {
    return tuple_import_code(field_types(inter_type), expr, action_prefix);
  }

  String* decl_type_import_code(RecordInterType inter_type, String expr, String action_prefix) {
    return record_import_code(fields(inter_type), expr, action_prefix);

  }

  String* decl_type_import_code(NamedInterType inter_type, String expr, String action_prefix) {
    return named_type_import_code(inter_type, expr, action_prefix);
  }

  String* decl_type_import_code(UnionInterType inter_type, String expr, String action_prefix) {
    return type_union_import_code(inter_types(inter_type), expr, action_prefix);
  }

  String* decl_type_import_code(TaggedInterType inter_type, String expr, String action_prefix) {
    unique_id = printed(_counter_(:any_value_will_do));
    out_var = "var_" & unique_id;
    next_action_prefix = "Obj " & out_var & " = ";
    untagged_type = untagged_type(inter_type);
    if untagged_type :: <NamedInterType, UnionInterType> and in(untagged_type, declared_types):
      type_name = input_types_names(untagged_type, !!);
      unique_id = printed(_counter_(:any_value_will_do));
      in_var = "var_" & unique_id;
      code = (type_name & " " & in_var & " = " & expr & ".inner;");
      code = code & import_code_ex(untagged_type, in_var, next_action_prefix);
    else
      code = import_code(untagged_type, expr, next_action_prefix);
    ;
    tag = object(type_tag(inter_type));
    instr = action_prefix & "Builder.createTaggedObj(Generated." & symb_idx_name(tag) & ", " & out_var & ");";
    return (code | instr);


    String* import_code(DeclInterType inter_type, String expr, String action_prefix) =
      decl_type_import_code(inter_type, expr, action_prefix);


    String* import_code(<BasicInterType, CollInterType> inter_type, String expr, String action_prefix) {
      return import_code_ex(inter_type, expr & ".inner", action_prefix);
    }
  }

  //////////////////////////////////////////////////////////////////////////////

  String* import_code_ex(InterType it, String expr, String action_prefix) {
    if in(it, declared_types):
      fail if not it :: DeclInterType; ## BAD
      if not is_simplifiable(it):
        type_name = input_types_names(it, !!);
        return (action_prefix & "Generated." & decl_type_import_funct_name(type_name) & "(" & expr & ");");
      ;
    ;

    return match (it)
      bool          = (action_prefix & "SymbObj.get(" & expr & ");"),
      integer       = (action_prefix & "IntObj.get(" & expr & ");"),
      float         = (action_prefix & "new FloatObj(" & expr & ");"),
      string        = (action_prefix & "Conversions.stringToObj(" & expr & ");"),
      symbol(s?)    = (action_prefix & "SymbObj.get(" & symb_idx_name(s) & ");"),
      tuple()       |
      record()      |
      union()       = undefined, // They are supposed to always be declared
      named()       = import_code_ex(named_interface_types_defs(it, !!), expr, action_prefix),
      seq(t?)       = array_import_code(t, expr, action_prefix, "Builder.createSeq"),
      set(t?)       = array_import_code(t, expr, action_prefix, "Builder.createSet"),
      tagged()      = tagged_value_import_code(it, expr, action_prefix),
      generic       = if treat_generic_as_value
                        then (action_prefix & "((ValueBase) " & expr & ").asObj();")
                        else (action_prefix & "Conversions.convertText(" & expr & ");");
  }


  String* named_type_import_code(NamedInterType inter_type, String expr, String action_prefix) =
    if in(inter_type, declared_types)
      then (action_prefix & decl_type_import_funct_name(input_types_names(inter_type, !!)) & "(" & expr & ");")
      else import_code_ex(:generic, expr, action_prefix);


  String* type_union_import_code([+UnionAltInterType] types, String expr, String action_prefix) {
if action_prefix != "return ":
  print "************************************************";
  print (types, expr, action_prefix);
;

    unique_id = printed(_counter_(:any_value_will_do));
    in_var = "var_" & unique_id;
    unique_id = printed(_counter_(:any_value_will_do));
    out_var = "var_" & unique_id;

    is_return = action_prefix == "return "; ## BAD BAD BAD

    code = ("Obj " & out_var & ";" if not is_return);
    local_action = if is_return then action_prefix else out_var & " = ";
    for t @ i <- isort(types):
      type_name = input_types_names(t, !!);
      code = code & (
        #(if i > 0 then "else " else "") & "if (" & expr & " instanceof " & type_name & ") {",
        "  " & type_name & " " & in_var & " = (" & type_name & ") " & expr & ";",
        "  " & local_action & decl_type_import_funct_name(type_name) & "(" & in_var & ");",
        "}"
      );
    ;

    return code & (
      "else",
      "  throw Miscellanea.internalFail();",
      action_prefix & out_var & ";" if not is_return
    );
  }


  String* record_import_code([+Symbol -> InterType] fields, String expr, String action_prefix) {
    unique_id = printed(_counter_(:any_value_will_do));
    keys_var = "keys_" & unique_id;
    values_var = "values_" & unique_id;

    count = |fields|;

    code = (
      "Obj[] " & keys_var   & " = new Obj[" & printed(count) & "];",
      "Obj[] " & values_var & " = new Obj[" & printed(count) & "];"
    );

    field_names = java_adjusted_unambiguous_lower_camel_case_names(keys(fields));
    for l, n @ i <- isort(field_names):
      code = (code | keys_var & "[" & printed(i) & "] = " & native_expr(object(l)) & ";");
      field_expr = expr & "." & field_names(l, !!);
      asgnm_prefix = values_var & "[" & printed(i) & "] = ";
      code = code & import_code_ex(fields(l, !!), field_expr, asgnm_prefix);
    ;

    map_creation_expr = "Builder.createMap(" & keys_var & ", " & values_var & ", " & printed(count) & ")";
    return (code | action_prefix & map_creation_expr & ";");
  }


  String* tuple_import_code(InterType+ types, String expr, String action_prefix) {
    unique_id = printed(_counter_(:any_value_will_do));

    field_vars = ("field" & printed(i) & "_" & unique_id : t @ i <- types);
    fields_code = (import_code_ex(t, expr & ".item" & printed(i+1), "Obj " & field_vars(i) & " = ") : t @ i <- types);

    tuple_instr = action_prefix & "Builder.createSeq(new Obj[] {" & append(field_vars, ", ") & "});";

    return (join(fields_code) | tuple_instr);
  }


  String* array_import_code(InterType elem_type, String expr, String action_prefix, String ctor) {
    unique_id = printed(_counter_(:any_value_will_do));
    expr_var = "expr" & unique_id;
    idx_var = "idx" & unique_id;
    array_var = "array" & unique_id;

    elem_code = import_code_ex(elem_type, expr_var & "[" & idx_var & "]", array_var & "[" & idx_var & "] = ");

    native_elem_type = if treat_generic_as_value
      then return_value_type(elem_type)
      else input_arg_type(elem_type);

    return (
      native_elem_type & "[] " & expr_var & " = " & expr & ";",
      "Obj[] " & array_var & " = new Obj[" & expr_var & ".length];",
      "for (int " & idx_var & " = 0 ; " & idx_var & " < " & expr_var & ".length ; " & idx_var & "++) {"
    ) & indent_lines(elem_code) & (
      "}",
      action_prefix & ctor & "(" & array_var & ");"
    );
  }


  String* tagged_value_import_code(TaggedInterType tagged_type, String expr, String action_prefix) {
    return import_code_ex(:generic, expr, action_prefix) if tagged_type == :generic;
    unique_id = printed(_counter_(:any_value_will_do));
    out_var = "var_" & unique_id;
    code = import_code_ex(untagged_type(tagged_type), expr, "Obj " & out_var & " = ");
    tag = object(type_tag(tagged_type));
    instr = action_prefix & "Builder.createTaggedObj(Generated." & symb_idx_name(tag) & ", " & out_var & ");";
    return (code | instr);
  }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

implicit prg : CompiledPrg {
  String* export_code(SymbolInterType inter_type, String type_name, String expr, String action_prefix) {
    return (action_prefix & type_name & ".singleton;");
  }

  String* export_code(TupleInterType inter_type, String type_name, String expr, String action_prefix) {
    return tuple_export_code(untag(inter_type), type_name, expr, action_prefix);
  }

  String* export_code(RecordInterType inter_type, String type_name, String expr, String action_prefix) {
    return record_export_code(untag(inter_type), type_name, expr, action_prefix);
  }

  String* export_code(NamedInterType inter_type, String type_name, String expr, String action_prefix) {
    assert in(inter_type, declared_types);
    return export_code(inter_type, expr, action_prefix);
    // type_name = output_types_names(inter_type, !!);
    // return (action_prefix & decl_type_export_funct_name(type_name) & "(" & expr & ");")
  }

  String* export_code(UnionInterType inter_type, String type_name, String expr, String action_prefix) {
    return type_union_export_code(inter_types(inter_type), expr, action_prefix);
  }

  String* export_code(TaggedInterType tagged_type, String type_name, String expr, String action_prefix) {
    unique_id = printed(_counter_(:any_value_will_do));
    in_var = "var_" & unique_id;
    code = ("Obj " & in_var & " = " & expr & ".getInnerObj();");
    untagged_type = untagged_type(tagged_type);
    if untagged_type :: <NamedInterType, UnionInterType> and in(untagged_type, declared_types):
      unique_id = printed(_counter_(:any_value_will_do));
      out_var = "var_" & unique_id;
      code = (code | type_name & " " & out_var & " = new " & type_name & "();");
      code = code & export_code(untagged_type, in_var, out_var & ".inner = ");
      code = (code | action_prefix & out_var & ";");
    else
      code = code & untagged_type_export_code(untagged_type, type_name, in_var, action_prefix);
    ;
    return code;


    String* untagged_type_export_code(DeclInterType inter_type, String type_name, String expr, String action_prefix) =
      export_code(inter_type, type_name, expr, action_prefix);


    String* untagged_type_export_code(<BasicInterType, CollInterType> inter_type, String type_name, String expr, String action_prefix) {
      unique_id = printed(_counter_(:any_value_will_do));
      var = "var_" & unique_id;
      code = (type_name & " " & var & " = new " & type_name & "();");
      code = code & export_code(inter_type, expr, var & ".inner = ");
      return (code | action_prefix & var & ";");
    }
  }

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  String* export_code(InterType it, String expr, String action_prefix) {
    if in(it, declared_types):
      fail if not it :: DeclInterType; ## BAD
      if not is_simplifiable(it):
        type_name = output_types_names(it, !!);
        return (action_prefix & "Generated." & decl_type_export_funct_name(type_name) & "(" & expr & ");");
      ;
    ;

    return match (it)
      bool                = (action_prefix & expr & ".getBool();"),
      integer             = (action_prefix & expr & ".getLong();"),
      float               = (action_prefix & expr & ".getDouble();"),
      string              = (action_prefix & expr & ".getString();"),
      symbol()            = (action_prefix & output_types_names(it, !!) & ".singleton;"),
      tuple()             |
      record()            |
      union()             = undefined, // They are supposed to always be declared
      named()             = export_code(named_interface_types_defs(it, !!), expr, action_prefix),
      seq(t?)             |
      set(t?)             = array_export_code(t, expr, action_prefix),
      tagged()            = tagged_type_export_code(it, expr, action_prefix),
      generic             = (action_prefix & "Conversions.exportAsValue(" & expr & ");");
  }


  String* tagged_type_export_code(TaggedInterType tagged_type, String expr, String action_prefix) {
    return export_code(:generic, expr, action_prefix) if tagged_type == :generic;
    unique_id = printed(_counter_(:any_value_will_do));
    in_var = "var_" & unique_id;
    instr = "Obj " & in_var & " = " & expr & ".getInnerObj();";
    untagged_type = untagged_type(tagged_type);
    return (instr) & export_code(untagged_type, in_var, action_prefix);
  }


  String* type_union_export_code([+UnionAltInterType] types, String expr, String action_prefix) {
if action_prefix != "return ":
  print "** ** ** ** ** ** ** ** ** ** ** ** ** **";
  print (types, expr, action_prefix);
;

    unique_id = printed(_counter_(:any_value_will_do));

    symb_types   = [t : t <- types, t :: SymbolInterType];
    tagged_types = [t : t <- types, t :: TaggedInterType];
    named_types  = [t : t <- types, t :: NamedInterType];
    assert symb_types & tagged_types & named_types == types;

    symbol_type_map = [symbol(t) -> t : t <- symb_types] &
                      [s -> t : t <- named_types, s <- symbols(t, named_interface_types_defs($, !!))];

    tag_type_map = [type_tag(t) -> t : t <- tagged_types] &
                   [s -> t : t <- named_types, s <- tags(t, named_interface_types_defs($, !!))];

    code = ();

    if symbol_type_map != []:
      if |symbol_type_map| > 1:
        symbs_code = ("switch (" & expr & ".getSymbId()) {");
        for s, t @ i <- isort(symbol_type_map):
          symbs_code = symbs_code & (
            "  case " & symb_idx_name(s) & ":",
            "    " & action_prefix & output_types_names(t, !!) & ".singleton;",
            "    break" if action_prefix != "return ", ## BAD BAD BAD
            ""
          );
        ;
        symbs_code = (symbs_code | "  default:", "    throw Miscellanea.internalFail();", "}");

      else
        only_type = only(values(symbol_type_map));
        symbs_code = (action_prefix & output_types_names(only_type, !!) & ".singleton;");
      ;
      symbs_code = ("if (" & expr & ".isSymb()) {") & indent_lines(symbs_code) & ("}") if tag_type_map != [];
      code = code & symbs_code;
    ;

    if tag_type_map != []:
      if |tag_type_map| > 1:
        tagged_values_code = ("switch (" & expr & ".getTagId()) {");
        for tag, type @ i <- isort(tag_type_map):
          type_name = output_types_names(type, !!);
          tagged_values_code = tagged_values_code & (
            "  case " & symb_idx_name(object(tag)) & ":",
            "    " & action_prefix & decl_type_export_funct_name(type_name) & "(" & expr & ");",
            ""
          );
        ;
        tagged_values_code = (tagged_values_code | "  default:", "    throw Miscellanea.internalFail();", "}");

      else
        type_name = output_types_names(only(values(tag_type_map)), !!);
        tagged_values_code = (action_prefix & decl_type_export_funct_name(type_name) & "(" & expr & ");");
      ;
      if symbol_type_map != []:
        tagged_values_code = ("else {") & indent_lines(tagged_values_code) & ("}");
      ;
      code = code & tagged_values_code;
    ;

    return code;
  }


  String* record_export_code([+Symbol -> InterType] fields, String type_name, String expr, String action_prefix) {
    unique_id = printed(_counter_(:any_value_will_do));
    record_var = "record_" & unique_id;

    field_names = java_adjusted_unambiguous_lower_camel_case_names(keys(fields));

    record_inst_instr = type_name & " " & record_var & " = new " & type_name & "();";
    asgnm_code = join(({
        asgnm_text = record_var & "." & field_names(l, !!) & " = ";
        field_unique_id = printed(_counter_(:any_value_will_do));
        field_var = "var_" & field_unique_id;
        field_store_instr = "Obj " & field_var & " = " & expr & ".lookupField(" & symb_idx_name(l) & ");";
        return (field_store_instr) & export_code(t, field_var, asgnm_text);
      } : l, t <- isort(fields)
    ));

    return (record_inst_instr) & (asgnm_code | action_prefix & record_var & ";");
  }


  String* tuple_export_code(InterType+ types, String type_name, String expr, String action_prefix) {
    unique_id = printed(_counter_(:any_value_will_do));
    tuple_var = "tuple_" & unique_id;

    tuple_instantiation_instr = type_name & " " & tuple_var & " = new " & type_name & "();";

    asgnm_code = join(({
        asgnm_text = tuple_var & ".item" & printed(i+1) & " = ";
        return export_code(t, expr & ".getObjAt(" & printed(i) & ")", asgnm_text);
      } : t @ i <- types
    ));

    return (tuple_instantiation_instr) & (asgnm_code | action_prefix & tuple_var & ";");
  }


  String* array_export_code(InterType elem_type, String expr, String action_prefix) {
    return match (elem_type)
      bool                = (action_prefix & "Conversions.toBoolArray(" & expr & ");"),
      integer             = (action_prefix & "Conversions.toLongArray(" & expr & ");"),
      float               = (action_prefix & "Conversions.toDoubleArray(" & expr & ");"),
      string              = (action_prefix & "Conversions.toStringArray(" & expr & ");"),
      generic             = (action_prefix & "Conversions.toValueArray(" & expr & ");"),
      tagged(_, generic)  = array_export_code(:generic, expr, action_prefix),
      tuple()             |
      record()            |
      seq()               |
      set()               |
      named()             |
      tagged()            = generic_array_export_code(elem_type, expr, action_prefix);


    String* generic_array_export_code(InterType elem_type, String expr, String action_prefix) {
      unique_id = printed(_counter_(:any_value_will_do));
      expr_var = "expr" & unique_id;
      size_var = "size" & unique_id;
      array_var = "array" & unique_id;
      buffer_var = "buffer" & unique_id;
      elt_var = "elt" & unique_id;
      idx_var = "idx" & unique_id;
      out_elem_type = return_value_type(elem_type);

      return (
        "Obj " & expr_var & " = " & expr & ";",
        "int " & size_var & " = " & expr_var & ".getSize();",
        out_elem_type & "[] " & array_var & " = new " & array_new_expr(elem_type, size_var) & ";",
        "Obj[] " & buffer_var & " = " & expr_var & ".getArray((Obj[]) null);",
        "for (int " & idx_var & " = 0 ; " & idx_var & " < " & size_var & " ; " & idx_var & "++) {",
        "  Obj " & elt_var & " = " & buffer_var & "[" & idx_var & "];"
      ) & indent_lines(export_code(elem_type, elt_var, array_var & "[" & idx_var & "++] = ")) & (
        "}",
        action_prefix & array_var & ";"
      );
    }
  }


  String array_new_expr(InterType elem_type, String size_expr) =
    seq(t?) | set(t?) = array_new_expr(t, size_expr) & "[]",
    _                 = return_value_type(elem_type) & "[" & size_expr & "]";
}

////////////////////////////////////////////////////////////////////////////////

implicit typedefs : [TypeName -> NeType] {
  [TypeSymbol] reachable_type_symbols([NeType] types) {
    type_symbs = [ts : t <- types, ts <- retrieve_type_symbs(t)];
    loop
      nested_type_symbs = [
        nts : ts <- type_symbs,
              t = cast_ne_type(expand_type_ref(ts, typedefs)),
              nts <- retrieve_type_symbs(t)
      ];

      new_type_symbs = nested_type_symbs - type_symbs;
      return type_symbs if new_type_symbs == [];
      type_symbs = type_symbs & new_type_symbs;
    ;
  }


  NeType expand_top_level_type_refs(NeType type) =
    symb_type()         |
    atom_type           |
    integer             |
    low_ints()          |
    high_ints()         |
    int_range()         |
    float_type          |
    empty_seq_type      |
    empty_rel_type      |
    type_var()          |
    ne_seq_type()       |
    ne_set_type()       |
    ne_map_type()       |
    ne_bin_rel_type()   |
    ne_tern_rel_type()  |
    ne_record_type()    |
    tuple_type()        |
    tag_obj_type()      = type,
    type_ref(ts?)       = expand_top_level_type_refs(cast_ne_type(expand_type_ref(ts, typedefs))),
    union_type(ts?)     = ne_union_type([expand_top_level_type_refs(t) : t <- ts]);


  Bool is_nameable(NeType type) {
    return false if is_subset(type, type_bool) or is_subset(type, type_string);
    return is_symb_singl_type(type) or is_tuple(type) or is_record(type) or is_union(type) or is_tagged(type);


    Bool is_tuple(NeType type) {
      maybe_types = maybe_tuple_type_fields(type);
      if maybe_types != nothing:
        types = value(maybe_types);
        size = |types|;
        return true if size >= 2 and size <= 8;
      ;
      return false;
    }


    Bool is_record(NeType type) {
      maybe_fields = maybe_record_type_fields(type);
      if maybe_fields != nothing:
        types = value(maybe_fields);
        return true if not (l, info <- types : info.optional);
      ;
      return false;
    }


    Bool is_tagged(NeType type) {
      if is_subset(type, type_tagged_obj):
        tag_type = tag_supertype(type);
        return true if is_symb_singl_type(tag_type);
      ;
      return false;
    }


    Bool is_union(NeType type) =
      union_type(ts?)   = not (t <- ts : not is_symb_singl_type(t) and not is_tagged(t)),
      type_ref(ts?)     = is_union(cast_ne_type(expand_type_ref(ts, typedefs))),
      _                 = false;
  }
}


implicit prg : CompiledPrg, typedefs : [TypeName -> NeType] {
  InterType interface_type(NeType type) {
    return interface_type(type, 8);


    InterType interface_type(NeType type, Nat depth) {
      // Named types
      if type :: TypeRef:
        type_symb = type_symb(type);
        return :named(type_symb) if in(type_symb, named_interface_types);
      ;

      // Atomic or standard types
      for it <- (:bool, :integer, :float, :string):
        return it if is_subset(type, internal_type(it));
      ;

      // Giving up if we're too deep in the call stack
      return :generic if depth == 0;

      // Sequences, including tuples
      if is_subset(type, type_seq):
        return seq_or_tuple_interface_type(type, depth);
      ;

      // Sets
      if is_subset(type, type_set):
        return set_interface_type(type, depth);
      ;

      // Binary relations, including records and maps
      if is_subset(type, type_bin_rel):
        return record_map_or_bin_rel_interface_type(type, depth);
      ;

      // // Ternary relations
      // if is_subset(type, type_tern_rel):
      //   return tern_rel_interface_type(type, depth);
      // ;

      // Monomorphically tagged types
      if is_subset(type, type_tagged_obj) and is_symb_singl_type(tag_supertype(type)):
        return monomorphically_tagged_values_interface_type(type, depth);
      ;

      // Any combination of symbols and tagged values
      if is_subset(type, ne_union_type([atom_type, type_tagged_obj])):
        return symbols_and_tagged_values_interface_type(type, depth);
      ;

      return :generic;
    }


    InterType seq_or_tuple_interface_type(NeType type, NzNat depth) {
      rem_depth = nat(depth - 1);

      maybe_types = maybe_tuple_type_fields(type);
      if maybe_types != nothing:
        types = value(maybe_types);
        size = |types|;
        return :tuple((interface_type(t, rem_depth) : t <- types)) if size >= 2 and size <= 8;
      ;

      elem_type = seq_elem_supertype(type);
      fail if elem_type == empty_type;
      return :seq(interface_type(elem_type, rem_depth));
    }


    InterType set_interface_type(NeType type, NzNat depth) {
      elem_type = set_elem_supertype(type);
      fail if elem_type == empty_type;
      return :set(interface_type(elem_type, nat(depth-1)));
    }


    InterType record_map_or_bin_rel_interface_type(NeType type, NzNat depth) {
      rem_depth = nat(depth - 1);

      maybe_fields = maybe_record_type_fields(type);
      if maybe_fields != nothing:
        types = value(maybe_fields);
        if not (l, info <- types : info.optional):
          return :record([untag(l) -> interface_type(info.type, rem_depth) : l, info <- types]);
        ;
      ;

      return :generic;
    }


    // InterType tern_rel_interface_type(NeType type, NzNat depth) {
    //   args_types = tern_rel_args_supertypes(type);
    //   fail if not args_types :: (NeType, NeType, NeType);
    //   return :tern_rel((interface_type(t) : t <- args_types));
    // }


    InterType monomorphically_tagged_values_interface_type(NeType type, NzNat depth) {
      tag = untag(only_symb(tag_supertype(type)));
      untagged_type = untagged_objs_supertype(type);
      fail if untagged_type == empty_type;
      untagged_inter_type = interface_type(untagged_type, nat(depth-1));
      return :tagged(tag, untagged_inter_type);
    }


    InterType symbols_and_tagged_values_interface_type(NeType type, NzNat depth) =
      union_type(ts?) = union_type_interface_type(ts, depth),
      symb_type(s?)   = :symbol(untag(s)),
      _               = :generic;


    InterType union_type_interface_type([+NeType] types, NzNat depth) {
      exp_types = (expand_top_level_type_refs(t) : t <- isort(types));
      if exp_types :: < SymbType, tag_obj_type(tag_type: SymbType, obj_type: NeType),
                        union_type([+<SymbType, tag_obj_type(tag_type: SymbType, obj_type: NeType)>])
                      >+:
        symbols = (
          match (exp_type)
            symb_type(s?)   = [untag(s)],
            tag_obj_type()  = [],
            union_type(ts?) = [untag(t) : t <- ts, symb_type() ?= t]
          : exp_type <- exp_types
        );

        tags = (
          match (exp_type)
            symb_type()     = [],
            tag_obj_type()  = [untag(exp_type.tag_type)],
            union_type(ts?) = [untag(t.tag_type) : t <- ts, tag_obj_type() ?= t]
          : exp_type <- exp_types
        );

        if not intersect(symbols) and not intersect(tags):
          rem_depth = nat(depth - 1);
          inter_types = [interface_type(t, rem_depth) : t <- types];
          return :union(inter_types) if inter_types :: [+UnionAltInterType];
        ;
      ;
      return :generic;
    }
  }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

## DOESN'T IT ALREADY EXIST, EITHER IN THE STANDARD LIBRARY OR ELSEWHERE?
Bool intersect([T]* sets) {
  for s1 @ i1 <- sets:
    for i2 = i1+1 .. |sets|:
      s2 = sets(i2);
      return true if (x <- s1 : s2(x));
    ;
  ;
  return false;
}


implicit typedefs : [TypeName -> NeType] {
  NeType expand_top_level_type_refs(NeType type) =
    symb_type()         |
    atom_type           |
    integer             |
    low_ints()          |
    high_ints()         |
    int_range()         |
    float_type          |
    empty_seq_type      |
    empty_rel_type      |
    type_var()          |
    ne_seq_type()       |
    ne_set_type()       |
    ne_map_type()       |
    ne_bin_rel_type()   |
    ne_tern_rel_type()  |
    ne_record_type()    |
    tuple_type()        |
    tag_obj_type()      = type,
    type_ref(ts?)       = expand_top_level_type_refs(cast_ne_type(expand_type_ref(ts, typedefs))),
    union_type(ts?)     = ne_union_type([expand_top_level_type_refs(t) : t <- ts]);
}


[NamedInterType] nested_named_types(InterType inter_type) =
  named() = [inter_type],
  _       = search_nested(inter_type, nested_named_types);


[X] search_nested(InterType inter_type, (InterType -> [X]) nested) =
  bool            |
  integer         |
  float           |
  string          |
  generic         |
  symbol()        |
  named()         = [],
  tuple(ts?)      = [x : t <~ ts, x <- nested(t)],
  record(fs?)     = [x : unused_var, t <- fs, x <- nested(t)],
  union(ts?)      = [x : t <- ts, x <- nested(t)],
  tagged(_, t?)   |
  seq(t?)         |
  set(t?)         = nested(t);
