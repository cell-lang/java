type AtomicInterType    = bool, integer, float, string, date, time;
type BasicInterType     = AtomicInterType, generic;

type TupleInterType     = tuple(InterType+);
type RecordInterType    = record([+Symbol -> InterType]);

type TaggedInterType[T] = tagged(Symbol, T);
type TaggedInterType    = TaggedInterType[InterType];

type OptionalInterType  = optional(InterType);

type NamedInterType     = named(TypeSymbol);

type CollInterType      = seq(InterType),
                          set(InterType),
                          map(KeyInterType, InterType);

type KeyInterType       = integer, string, date, time, generic;

type SymbolInterType    = symbol(Symbol);

type UnionAltInterType  = SymbolInterType, TaggedInterType, NamedInterType;
type UnionInterType     = union([+UnionAltInterType]);

type InterType          = BasicInterType,
                          SymbolInterType,
                          TupleInterType,
                          RecordInterType,
                          CollInterType,
                          TaggedInterType,
                          OptionalInterType,
                          NamedInterType,
                          UnionInterType;

////////////////////////////////////////////////////////////////////////////////

type DeclInterType  = SymbolInterType, TupleInterType, RecordInterType, NamedInterType,
                      UnionInterType, TaggedInterType;

////////////////////////////////////////////////////////////////////////////////

Symbol symbol(SymbolInterType)  = symbol(s?) = s;

InterType+ field_types(TupleInterType)  = tuple(ts?) = ts;

[+Symbol -> InterType] fields(RecordInterType) = record(fs?) = fs;

Symbol type_tag(TaggedInterType)          = tagged(s?, _) = s;
T      untagged_type(TaggedInterType[T])  = tagged(_, t?) = t;

TypeSymbol type_symb(NamedInterType)  = named(ts?) = ts;

[+UnionAltInterType] inter_types(UnionInterType) = union(ts?) = ts;

////////////////////////////////////////////////////////////////////////////////

[Symbol] symbols(DeclInterType inter_type, (NamedInterType -> DeclInterType) inter_type_def) =
  symbol(s?)  = [s],
  named()     = symbols(inter_type_def(inter_type), inter_type_def),
  union(ts?)  = [s : t <- ts, s <- symbols(t, inter_type_def)],
  tuple()     |
  record()    |
  tagged()    = [];


[Symbol] tags(DeclInterType inter_type, (NamedInterType -> DeclInterType) inter_type_def) =
  tagged(s?, _) = [s],
  named()       = tags(inter_type_def(inter_type), inter_type_def),
  union(ts?)    = [s : t <- ts, s <- tags(t, inter_type_def)],
  symbol()      |
  tuple()       |
  record()      = [];

////////////////////////////////////////////////////////////////////////////////

NeType internal_type(AtomicInterType) =
  bool        = type_bool,
  integer     = integer,
  float       = float_type,
  string      = type_string,
  date        = type_date,
  time        = type_time;


implicit prg : CompiledPrg {
  String input_arg_type(InterType it) {
    if in(it, declared_types) {
      fail if not it :: DeclInterType; ## BAD
      return input_types_names(it, !!) if not is_simplifiable(it);
    }

    return match (it)
      bool              = "boolean",
      integer           = "long",
      float             = "double",
      date              = "java.time.LocalDate",
      time              = "java.time.LocalDateTime",
      optional(t?)      = input_arg_obj_type(t),
      symbol()          |
      tuple()           |
      record()          |
      union()           = undefined,
      named(n?)         = input_arg_type(named_interface_types_defs(it, !!)),
      seq(t?)           |
      set(t?)           = input_arg_type(t) & "[]",
      map(k?, v?)       = "java.util.HashMap<" & input_arg_obj_type(k) & ", " & input_arg_obj_type(v) & ">",
      tagged(_, t?)     = input_arg_type(t),
      string            |
      generic           = "String";
  }


  String input_arg_obj_type(InterType it) =
    bool    = "Boolean",
    integer = "Long",
    float   = "Double",
    _       = input_arg_type(it);


  String return_value_type(InterType it) = return_value_type(it, output_types_names);


  String return_value_type(InterType it, [DeclInterType -> String] types_names) {
    if in(it, declared_types) {
      fail if not it :: DeclInterType; ## BAD
      return types_names(it, !!) if not is_simplifiable(it);
    }

    return match (it)
      bool              = "boolean",
      integer           = "long",
      float             = "double",
      string            = "String",
      date              = "java.time.LocalDate",
      time              = "java.time.LocalDateTime",
      optional(t?)      = ret_value_obj_type(t),
      symbol()          |
      tuple()           |
      record()          |
      union()           = undefined,
      named()           = return_value_type(named_interface_types_defs(it, !!), types_names),
      seq(t?)           |
      set(t?)           = return_value_type(t, types_names) & "[]",
      map(k?, v?)       = "java.util.HashMap<" & ret_value_obj_type(k) & ", " & ret_value_obj_type(v) & ">",
      tagged(_, t?)     = return_value_type(t, types_names),
      generic           = "String";
  }


  String ret_value_obj_type(InterType it) =
    bool    = "Boolean",
    integer = "Long",
    float   = "Double",
    _       = return_value_type(it);
}

////////////////////////////////////////////////////////////////////////////////

implicit prg : CompiledPrg {
  String* import_code(InterType it, String expr, String action_prefix) =
    import_code_ex(it, expr, action_prefix);


  String* decl_type_import_code(SymbolInterType inter_type, String expr, String action_prefix) {
    return (action_prefix & "SymbObj.get(" & symb_idx_qual_name(symbol(inter_type)) & ");");
  }

  String* decl_type_import_code(TupleInterType inter_type, String expr, String action_prefix) {
    return tuple_import_code(field_types(inter_type), expr, action_prefix);
  }

  String* decl_type_import_code(RecordInterType inter_type, String expr, String action_prefix) {
    return record_import_code(fields(inter_type), expr, action_prefix);
  }

  String* decl_type_import_code(NamedInterType inter_type, String expr, String action_prefix) {
    return named_type_import_code(inter_type, expr, action_prefix);
  }

  String* decl_type_import_code(UnionInterType inter_type, String expr, String action_prefix) {
    return type_union_import_code(inter_types(inter_type), expr, action_prefix);
  }

  String* decl_type_import_code(TaggedInterType inter_type, String expr, String action_prefix) {
    unique_id = printed(_counter_(:any_value_will_do));
    out_var = "var_" & unique_id;
    next_action_prefix = "Obj " & out_var & " = ";
    untagged_type = untagged_type(inter_type);
    if untagged_type :: <NamedInterType, UnionInterType> and in(untagged_type, declared_types) {
      type_name = input_types_names(untagged_type, !!);
      unique_id = printed(_counter_(:any_value_will_do));
      in_var = "var_" & unique_id;
      code = (type_name & " " & in_var & " = " & expr & ".value;");
      code = code & import_code_ex(untagged_type, in_var, next_action_prefix);
    }
    else {
      code = import_code(untagged_type, expr, next_action_prefix);
    }
    tag = object(type_tag(inter_type));
    instr = action_prefix & "Builder.createTaggedObj(" & symb_idx_qual_name(tag) & ", " & out_var & ");";
    return (code | instr);


    String* import_code(DeclInterType inter_type, String expr, String action_prefix) =
      decl_type_import_code(inter_type, expr, action_prefix);


    String* import_code(<BasicInterType, CollInterType, OptionalInterType> inter_type, String expr, String action_prefix) {
      return import_code_ex(inter_type, expr & ".value", action_prefix);
    }
  }

  //////////////////////////////////////////////////////////////////////////////

  String* import_code_ex(InterType it, String expr, String action_prefix) {
    if in(it, declared_types) {
      fail if not it :: DeclInterType; ## BAD
      if not is_simplifiable(it) {
        type_name = input_types_names(it, !!);
        return (action_prefix & "Generated." & decl_type_import_funct_name(type_name) & "(" & expr & ");");
      }
    }

    return match (it)
      bool          = (action_prefix & "SymbObj.get(" & expr & ");"),
      integer       = (action_prefix & "IntObj.get(" & expr & ");"),
      float         = (action_prefix & "new FloatObj(" & expr & ");"),
      string        = (action_prefix & "Conversions.stringToObj(" & expr & ");"),
      date          = (action_prefix & "Conversions.dateToObj(" & expr & ");"),
      time          = (action_prefix & "Conversions.dateTimeToObj(" & expr & ");"),
      symbol(s?)    = (action_prefix & "SymbObj.get(" & symb_idx_qual_name(s) & ");"),
      tuple()       |
      record()      |
      union()       = undefined, // They are supposed to always be declared
      named()       = import_code_ex(named_interface_types_defs(it, !!), expr, action_prefix),
      seq(t?)       = array_import_code(t, expr, action_prefix, "Builder.createSeq"),
      set(t?)       = array_import_code(t, expr, action_prefix, "Builder.createSet"),
      map(k?, v?)   = map_import_code(k, v, expr, action_prefix),
      tagged()      = tagged_value_import_code(it, expr, action_prefix),
      optional(t?)  = optional_value_import_code(t, expr, action_prefix),
      generic       = (action_prefix & "Conversions.convertText(" & expr & ");");
  }


  String* named_type_import_code(NamedInterType inter_type, String expr, String action_prefix) =
    if in(inter_type, declared_types)
      then (action_prefix & decl_type_import_funct_name(input_types_names(inter_type, !!)) & "(" & expr & ");")
      else import_code_ex(:generic, expr, action_prefix);


  String* type_union_import_code([+UnionAltInterType] types, String expr, String action_prefix) {
if action_prefix != "return " {
  print "************************************************";
  print (types, expr, action_prefix);
}

    unique_id = printed(_counter_(:any_value_will_do));
    in_var = "var_" & unique_id;
    unique_id = printed(_counter_(:any_value_will_do));
    out_var = "var_" & unique_id;

    is_return = action_prefix == "return "; ## BAD BAD BAD

    code = ("Obj " & out_var & ";" if not is_return);
    local_action = if is_return then action_prefix else out_var & " = ";
    for t @ i <- isort(types) {
      type_name = input_types_names(t, !!);
      code = code & (
        {if i > 0 then "else " else ""} & "if (" & expr & " instanceof " & type_name & ") {",
        "  " & type_name & " " & in_var & " = (" & type_name & ") " & expr & ";",
        "  " & local_action & decl_type_import_funct_name(type_name) & "(" & in_var & ");",
        "}"
      );
    }

    return code & (
      "else",
      "  throw Miscellanea.internalFail();",
      action_prefix & out_var & ";" if not is_return
    );
  }


  String* record_import_code([+Symbol -> InterType] fields, String expr, String action_prefix) {
    unique_id = printed(_counter_(:any_value_will_do));
    keys_var = "keys_" & unique_id;
    values_var = "values_" & unique_id;

    count = |fields|;

    code = (
      "Obj[] " & keys_var   & " = new Obj[" & printed(count) & "];",
      "Obj[] " & values_var & " = new Obj[" & printed(count) & "];"
    );

    field_names = java_adjusted_unambiguous_lower_camel_case_names(keys(fields));
    for l, n @ i <- isort(field_names) {
      code = (code | keys_var & "[" & printed(i) & "] = " & native_expr(object(l), context=:wrapper) & ";");
      field_expr = expr & "." & field_names(l, !!);
      asgnm_prefix = values_var & "[" & printed(i) & "] = ";
      code = code & import_code_ex(fields(l, !!), field_expr, asgnm_prefix);
    }

    map_creation_expr = "Builder.createMap(" & keys_var & ", " & values_var & ", " & printed(count) & ")";
    return (code | action_prefix & map_creation_expr & ";");
  }


  String* tuple_import_code(InterType+ types, String expr, String action_prefix) {
    unique_id = printed(_counter_(:any_value_will_do));

    field_vars = ("field" & printed(i) & "_" & unique_id : t @ i <- types);
    fields_code = (import_code_ex(t, expr & ".item" & printed(i+1), "Obj " & field_vars(i) & " = ") : t @ i <- types);

    tuple_instr = action_prefix & "Builder.createSeq(new Obj[] {" & append(field_vars, ", ") & "});";

    return (join(fields_code) | tuple_instr);
  }


  String* array_import_code(InterType elem_type, String expr, String action_prefix, String ctor) {
    unique_id = printed(_counter_(:any_value_will_do));
    expr_var = "expr" & unique_id;
    idx_var = "idx" & unique_id;
    array_var = "array" & unique_id;

    elem_code = import_code_ex(elem_type, expr_var & "[" & idx_var & "]", array_var & "[" & idx_var & "] = ");

    native_elem_type = input_arg_type(elem_type);

    return (
      native_elem_type & "[] " & expr_var & " = " & expr & ";",
      "Obj[] " & array_var & " = new Obj[" & expr_var & ".length];",
      "for (int " & idx_var & " = 0 ; " & idx_var & " < " & expr_var & ".length ; " & idx_var & "++) {"
    ) & indent_lines(elem_code) & (
      "}",
      action_prefix & ctor & "(" & array_var & ");"
    );
  }


  String* map_import_code(KeyInterType key_type, InterType value_type, String expr, String action_prefix) {
    unique_id = printed(_counter_(:any_value_will_do));
    idx_var = "idx_" & unique_id;
    entry_var = "entry_" & unique_id;
    idx_var = "idx_" & unique_id;
    key_var = "key_" & unique_id;
    value_var = "value_" & unique_id;
    keys_var = "keys_" & unique_id;
    values_var = "values_" & unique_id;
    in_key_type = input_arg_obj_type(key_type);
    in_value_type = input_arg_obj_type(value_type);

    code = (
      "Obj[] " & keys_var & " = new Obj[" & expr & ".size()];",
      "Obj[] " & values_var & " = new Obj[" & expr & ".size()];",
      "int " & idx_var & " = 0;",
      "for (java.util.Map.Entry<" & in_key_type & ", " & in_value_type & "> " & entry_var & " : " & expr & ".entrySet()) {",
      "  " & in_key_type & " " & key_var & " = " & entry_var & ".getKey();",
      "  " & in_value_type & " " & value_var & " = " & entry_var & ".getValue();"
    );

    code = code & indent_lines(import_code(key_type, key_var, keys_var & "[" & idx_var & "] = "));
    code = code & indent_lines(import_code(value_type, value_var, values_var & "[" & idx_var & "] = "));

    return (
      code |
      "  " & idx_var & "++;",
      "}",
      action_prefix & "Builder.createMap(" & keys_var & ", " & values_var & ");"
    );
  }


  String* tagged_value_import_code(TaggedInterType tagged_type, String expr, String action_prefix) {
    return import_code_ex(:generic, expr, action_prefix) if tagged_type == :generic;
    unique_id = printed(_counter_(:any_value_will_do));
    out_var = "var_" & unique_id;
    code = import_code_ex(untagged_type(tagged_type), expr, "Obj " & out_var & " = ");
    tag = object(type_tag(tagged_type));
    instr = action_prefix & "Builder.createTaggedObj(" & symb_idx_qual_name(tag) & ", " & out_var & ");";
    return (code | instr);
  }


  String* optional_value_import_code(InterType inner_type, String expr, String action_prefix) {
    code = match (inner_type)
      bool    = (action_prefix & "Builder.createTaggedObj(SymbTable.JustSymbId, SymbObj.get(" & expr & ".booleanValue()));"),
      integer = (action_prefix & "Builder.createTaggedIntObj(SymbTable.JustSymbId, " & expr & ".longValue());"),
      float   = (action_prefix & "Builder.createTaggedObj(SymbTable.JustSymbId, new FloatObj(" & expr & ".doubleValue()));"),
      _       = import_code_ex(inner_type, expr, action_prefix);

    return (
      "if (" & expr & " != null) {",
    ) & indent_lines(code) & (
      "}",
      "else",
      "  " & action_prefix & "SymbObj.get(SymbTable.NothingSymbId);"
    );
  }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

implicit prg : CompiledPrg {
  String* export_code(SymbolInterType inter_type, String type_name, String expr, String action_prefix) {
    return (action_prefix & type_name & ".singleton;");
  }

  String* export_code(TupleInterType inter_type, String type_name, String expr, String action_prefix) {
    return tuple_export_code(untag(inter_type), type_name, expr, action_prefix);
  }

  String* export_code(RecordInterType inter_type, String type_name, String expr, String action_prefix) {
    return record_export_code(untag(inter_type), type_name, expr, action_prefix);
  }

  String* export_code(NamedInterType inter_type, String type_name, String expr, String action_prefix) {
    assert in(inter_type, declared_types);
    return export_code(inter_type, expr, action_prefix);
    // type_name = output_types_names(inter_type, !!);
    // return (action_prefix & decl_type_export_funct_name(type_name) & "(" & expr & ");")
  }

  String* export_code(UnionInterType inter_type, String type_name, String expr, String action_prefix) {
    return type_union_export_code(inter_types(inter_type), expr, action_prefix);
  }

  String* export_code(TaggedInterType tagged_type, String type_name, String expr, String action_prefix) {
    unique_id = printed(_counter_(:any_value_will_do));
    in_var = "var_" & unique_id;
    code = ("Obj " & in_var & " = " & expr & ".getInnerObj();");
    untagged_type = untagged_type(tagged_type);
    if untagged_type :: <NamedInterType, UnionInterType> and in(untagged_type, declared_types) {
      unique_id = printed(_counter_(:any_value_will_do));
      out_var = "var_" & unique_id;
      code = (code | type_name & " " & out_var & " = new " & type_name & "();");
      code = code & export_code(untagged_type, in_var, out_var & ".value = ");
      code = (code | action_prefix & out_var & ";");
    }
    else {
      code = code & untagged_type_export_code(untagged_type, type_name, in_var, action_prefix);
    }
    return code;


    String* untagged_type_export_code(DeclInterType inter_type, String type_name, String expr, String action_prefix) =
      export_code(inter_type, type_name, expr, action_prefix);


    String* untagged_type_export_code(<BasicInterType, CollInterType, OptionalInterType> inter_type, String type_name, String expr, String action_prefix) {
      unique_id = printed(_counter_(:any_value_will_do));
      var = "var_" & unique_id;
      code = (type_name & " " & var & " = new " & type_name & "();");
      code = code & export_code(inter_type, expr, var & ".value = ");
      return (code | action_prefix & var & ";");
    }
  }

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  String* export_code(InterType it, String expr, String action_prefix) {
    if in(it, declared_types) {
      fail if not it :: DeclInterType; ## BAD
      if not is_simplifiable(it) {
        type_name = output_types_names(it, !!);
        return (action_prefix & "Generated." & decl_type_export_funct_name(type_name) & "(" & expr & ");");
      }
    }

    return match (it)
      bool                = (action_prefix & expr & ".getBool();"),
      integer             = (action_prefix & expr & ".getLong();"),
      float               = (action_prefix & expr & ".getDouble();"),
      string              = (action_prefix & expr & ".getString();"),
      date                = (action_prefix & "Conversions.objToDate(" & expr & ");"),
      time                = (action_prefix & "Conversions.objToDateTime(" & expr & ");"),
      symbol()            = (action_prefix & output_types_names(it, !!) & ".singleton;"),
      tuple()             |
      record()            |
      union()             = undefined, // They are supposed to always be declared
      named()             = export_code(named_interface_types_defs(it, !!), expr, action_prefix),
      seq(t?)             |
      set(t?)             = array_export_code(t, expr, action_prefix),
      map(k?, v?)         = map_export_code(k, v, expr, action_prefix),
      tagged()            = tagged_type_export_code(it, expr, action_prefix),
      optional(t?)        = optional_type_export_code(t, expr, action_prefix),
      generic             = (action_prefix & "Conversions.exportAsText(" & expr & ");");
  }


  String* optional_type_export_code(InterType inner_type, String expr, String action_prefix) {
    code_nothing = (
      "if (" & expr & ".isSymb(SymbTable.NothingSymbId))",
      "  return null;"
    );
    code_just = match (inner_type)
      bool    = (action_prefix & "Boolean.valueOf(" & expr & ".getInnerObj().isSymb(SymbTable.TrueSymbId));"),
      integer = (action_prefix & "Long.valueOf(" & expr & ".getInnerLong());"),
      float   = (action_prefix & "Double.valueOf(" & expr & ".getInnerObj().getDouble());"),
      _       = { unique_id = _counter_(:any_value_will_do);
                  var = "var_" & printed(unique_id);
                  instr = "Obj " & var & " = " & expr & ".getInnerObj();";
                  return (instr) & export_code(inner_type, var, action_prefix);
                };
    return code_nothing & code_just;
  }


  String* tagged_type_export_code(TaggedInterType tagged_type, String expr, String action_prefix) {
    return export_code(:generic, expr, action_prefix) if tagged_type == :generic;
    unique_id = printed(_counter_(:any_value_will_do));
    in_var = "var_" & unique_id;
    instr = "Obj " & in_var & " = " & expr & ".getInnerObj();";
    untagged_type = untagged_type(tagged_type);
    return (instr) & export_code(untagged_type, in_var, action_prefix);
  }


  String* type_union_export_code([+UnionAltInterType] types, String expr, String action_prefix) {
if action_prefix != "return " {
  print "** ** ** ** ** ** ** ** ** ** ** ** ** **";
  print (types, expr, action_prefix);
}

    unique_id = printed(_counter_(:any_value_will_do));

    symb_types   = [t : t <- types, t :: SymbolInterType];
    tagged_types = [t : t <- types, t :: TaggedInterType];
    named_types  = [t : t <- types, t :: NamedInterType];
    assert symb_types & tagged_types & named_types == types;

    symbol_type_map = [symbol(t) -> t : t <- symb_types] &
                      [s -> t : t <- named_types, s <- symbols(t, named_interface_types_defs($, !!))];

    tag_type_map = [type_tag(t) -> t : t <- tagged_types] &
                   [s -> t : t <- named_types, s <- tags(t, named_interface_types_defs($, !!))];

    code = ();

    if symbol_type_map != [] {
      if |symbol_type_map| > 1 {
        symbs_code = ("switch (" & expr & ".getSymbId()) {");
        for s, t @ i <- isort(symbol_type_map) {
          symbs_code = symbs_code & (
            "  case " & symb_idx_base_name(s) & ":",
            "    " & action_prefix & output_types_names(t, !!) & ".singleton;",
            "    break" if action_prefix != "return ", ## BAD BAD BAD
            ""
          );
        }
        symbs_code = (symbs_code | "  default:", "    throw Miscellanea.internalFail();", "}");

      }
      else {
        only_type = only(values(symbol_type_map));
        symbs_code = (action_prefix & output_types_names(only_type, !!) & ".singleton;");
      }
      symbs_code = ("if (" & expr & ".isSymb()) {",) & indent_lines(symbs_code) & ("}") if tag_type_map != [];
      code = code & symbs_code;
    }

    if tag_type_map != [] {
      if |tag_type_map| > 1 {
        tagged_values_code = ("switch (" & expr & ".getTagId()) {");
        for tag, type @ i <- isort(tag_type_map) {
          type_name = output_types_names(type, !!);
          tagged_values_code = tagged_values_code & (
            "  case " & symb_idx_base_name(object(tag)) & ":",
            "    " & action_prefix & decl_type_export_funct_name(type_name) & "(" & expr & ");",
            ""
          );
        }
        tagged_values_code = (tagged_values_code | "  default:", "    throw Miscellanea.internalFail();", "}");

      }
      else {
        type_name = output_types_names(only(values(tag_type_map)), !!);
        tagged_values_code = (action_prefix & decl_type_export_funct_name(type_name) & "(" & expr & ");");
      }
      if symbol_type_map != []
        tagged_values_code = ("else {") & indent_lines(tagged_values_code) & ("}");
      code = code & tagged_values_code;
    }

    return code;
  }


  String* record_export_code([+Symbol -> InterType] fields, String type_name, String expr, String action_prefix) {
    unique_id = printed(_counter_(:any_value_will_do));
    record_var = "record_" & unique_id;

    field_names = java_adjusted_unambiguous_lower_camel_case_names(keys(fields));

    record_inst_instr = type_name & " " & record_var & " = new " & type_name & "();";
    asgnm_code = join(({
        asgnm_text = record_var & "." & field_names(l, !!) & " = ";
        field_unique_id = printed(_counter_(:any_value_will_do));
        field_var = "var_" & field_unique_id;
        field_store_instr = "Obj " & field_var & " = " & expr & ".lookupField(" & symb_idx_qual_name(l) & ");";
        return (field_store_instr) & export_code(t, field_var, asgnm_text);
      } : l, t <- isort(fields)
    ));

    return (record_inst_instr) & (asgnm_code | action_prefix & record_var & ";");
  }


  String* tuple_export_code(InterType+ types, String type_name, String expr, String action_prefix) {
    unique_id = printed(_counter_(:any_value_will_do));
    tuple_var = "tuple_" & unique_id;

    tuple_instantiation_instr = type_name & " " & tuple_var & " = new " & type_name & "();";

    asgnm_code = join(({
        asgnm_text = tuple_var & ".item" & printed(i+1) & " = ";
        return export_code(t, expr & ".getObjAt(" & printed(i) & ")", asgnm_text);
      } : t @ i <- types
    ));

    return (tuple_instantiation_instr) & (asgnm_code | action_prefix & tuple_var & ";");
  }


  String* array_export_code(InterType elem_type, String expr, String action_prefix) {
    return match (elem_type)
      bool                = (action_prefix & "Conversions.toBoolArray(" & expr & ");"),
      integer             = (action_prefix & "Conversions.toLongArray(" & expr & ");"),
      float               = (action_prefix & "Conversions.toDoubleArray(" & expr & ");"),
      string              = (action_prefix & "Conversions.toStringArray(" & expr & ");"),
      generic             = (action_prefix & "Conversions.toTextArray(" & expr & ");"),
      tagged(_, generic)  = array_export_code(:generic, expr, action_prefix),
      date                |
      time                |
      tuple()             |
      record()            |
      seq()               |
      set()               |
      map()               |
      named()             |
      tagged()            |
      optional()          |
      symbol()            |
      union()             = generic_array_export_code(elem_type, expr, action_prefix);


    String* generic_array_export_code(InterType elem_type, String expr, String action_prefix) {
      unique_id = printed(_counter_(:any_value_will_do));
      expr_var = "expr" & unique_id;
      size_var = "size" & unique_id;
      array_var = "array" & unique_id;
      buffer_var = "buffer" & unique_id;
      elt_var = "elt" & unique_id;
      idx_var = "idx" & unique_id;
      out_elem_type = return_value_type(elem_type);

      return (
        "Obj " & expr_var & " = " & expr & ";",
        "int " & size_var & " = " & expr_var & ".getSize();",
        out_elem_type & "[] " & array_var & " = new " & array_new_expr(elem_type, size_var) & ";",
        "Obj[] " & buffer_var & " = " & expr_var & ".getArray((Obj[]) null);",
        "for (int " & idx_var & " = 0 ; " & idx_var & " < " & size_var & " ; " & idx_var & "++) {",
        "  Obj " & elt_var & " = " & buffer_var & "[" & idx_var & "];"
      ) & indent_lines(export_code(elem_type, elt_var, array_var & "[" & idx_var & "] = ")) & (
        "}",
        action_prefix & array_var & ";"
      );
    }


    String array_new_expr(InterType elem_type, String size_expr) =
      seq(t?) | set(t?) = array_new_expr(t, size_expr) & "[]",
      _                 = return_value_type(elem_type) & "[" & size_expr & "]";
  }


  String* map_export_code(KeyInterType key_type, InterType value_type, String expr, String action_prefix) {
    unique_id = printed(_counter_(:any_value_will_do));
    map_var = "map_" & unique_id;
    iter_var = "iter_" & unique_id;
    key_var = "key_" & unique_id;
    value_var = "value_" & unique_id;
    out_key_var = "out_key_" & unique_id;
    out_value_var = "out_value_" & unique_id;

    out_type = return_value_type(:map(key_type, value_type));
    out_key_type = ret_value_obj_type(key_type);
    out_value_type = ret_value_obj_type(value_type);

    code = (
      out_type & " " & map_var & " = new " & out_type & "();",
      "BinRelIter " & iter_var & " = " & expr & ".getBinRelIter();",
      "while (!" & iter_var & ".done()) {",
      "  Obj " & key_var & " = " & iter_var & ".get1();",
      "  Obj " & value_var & " = " & iter_var & ".get2();",
      "  " & out_key_type & " " & out_key_var & ";",
      "  " & out_value_type & " " & out_value_var & ";"
    );

    code = code & indent_lines(export_code(key_type, key_var, out_key_var & " = "));
    code = code & indent_lines(export_code(value_type, value_var, out_value_var & " = "));

    return (
      code |
      "  " & map_var & ".put(" & out_key_var & ", " & out_value_var & ");",
      "  " & iter_var & ".next();",
      "}",
      action_prefix & " " & map_var & ";"
    );
  }
}

////////////////////////////////////////////////////////////////////////////////

implicit typedefs : [TypeName -> NeType] {
  [TypeSymbol] reachable_type_symbols([NeType] types) {
    type_symbs = [ts : t <- types, ts <- retrieve_type_symbs(t)];
    loop {
      nested_type_symbs = [
        nts : ts <- type_symbs,
              t = cast_ne_type(expand_type_ref(ts, typedefs)),
              nts <- retrieve_type_symbs(t)
      ];

      new_type_symbs = nested_type_symbs - type_symbs;
      return type_symbs if new_type_symbs == [];
      type_symbs = type_symbs & new_type_symbs;
    }
  }


  NeType expand_top_level_type_refs(NeType type) =
    symb_type()         |
    atom_type           |
    integer             |
    low_ints()          |
    high_ints()         |
    int_range()         |
    float_type          |
    empty_seq_type      |
    empty_rel_type      |
    type_var()          |
    ne_seq_type()       |
    ne_set_type()       |
    ne_map_type()       |
    ne_bin_rel_type()   |
    ne_tern_rel_type()  |
    ne_record_type()    |
    tuple_type()        |
    tag_obj_type()      = type,
    type_ref(ts?)       = expand_top_level_type_refs(cast_ne_type(expand_type_ref(ts, typedefs))),
    union_type(ts?)     = ne_union_type([expand_top_level_type_refs(t) : t <- ts]);


  Bool is_nameable(NeType type) {
    return false if (t <- special_cases : is_subset(type, t));
    return is_symb_singl_type(type) or is_tuple(type) or is_record(type) or is_union(type) or is_tagged(type);


    [+NeType] special_cases = [type_bool, type_string, type_date, type_time, type_maybe(type_any)];


    Bool is_tuple(NeType type) {
      maybe_types = maybe_tuple_type_fields(type);
      if maybe_types != nothing {
        types = value(maybe_types);
        size = |types|;
        return true if size >= 2 and size <= 8;
      }
      return false;
    }


    Bool is_record(NeType type) {
      maybe_fields = maybe_record_type_fields(type);
      if maybe_fields != nothing {
        types = value(maybe_fields);
        return true if not (l info <- types : info.optional);
      }
      return false;
    }


    Bool is_tagged(NeType type) {
      if is_subset(type, type_tagged_obj) {
        tag_type = tag_supertype(type);
        return true if is_symb_singl_type(tag_type);
      }
      return false;
    }


    Bool is_union(NeType type) =
      union_type(ts?)   = not (t <- ts : not is_symb_singl_type(t) and not is_tagged(t)),
      type_ref(ts?)     = is_union(cast_ne_type(expand_type_ref(ts, typedefs))),
      _                 = false;
  }
}


implicit prg : CompiledPrg, typedefs : [TypeName -> NeType] {
  InterType interface_type(NeType type) {
    return interface_type(type, 8);


    InterType interface_type(NeType type, Nat depth) {
      // Named types
      if type :: TypeRef {
        type_symb = type_symb(type);
        return :named(type_symb) if in(type_symb, named_interface_types);
      }

      // Atomic or standard types
      for it <- (:bool, :integer, :float, :string, :date, :time)
        return it if is_subset(type, internal_type(it));

      // Giving up if we're too deep in the call stack
      return :generic if depth == 0;

      // Sequences, including tuples
      if is_subset(type, type_seq)
        return seq_or_tuple_interface_type(type, depth);

      // Sets
      if is_subset(type, type_set)
        return set_interface_type(type, depth);

      // Maps, including records
      if is_subset(type, type_map)
        return map_record_interface_type(type, depth);

      // Binary relations, excluding records and maps
      if is_subset(type, type_bin_rel)
        return bin_rel_interface_type(type, depth);

      // // Ternary relations
      // if is_subset(type, type_tern_rel)
      //   return tern_rel_interface_type(type, depth);

      // Monomorphically tagged types
      if is_subset(type, type_tagged_obj) and is_symb_singl_type(tag_supertype(type))
        return monomorphically_tagged_values_interface_type(type, depth);

      // Maybe type
      if is_subset(type, type_maybe(type_any))
        if not is_subset(type, tag_obj_type(symb_type(:just), type_any))
          if not is_subset(type, symb_type(:nothing))
            return maybe_value_interface_type(type, depth);

      // Any combination of symbols and tagged values
      if is_subset(type, ne_union_type([atom_type, type_tagged_obj]))
        return symbols_and_tagged_values_interface_type(type, depth);

      return :generic;
    }


    InterType seq_or_tuple_interface_type(NeType type, NzNat depth) {
      rem_depth = nat(depth - 1);

      maybe_types = maybe_tuple_type_fields(type);
      if maybe_types != nothing {
        types = value(maybe_types);
        size = |types|;
        return :tuple((interface_type(t, rem_depth) : t <- types)) if size >= 2 and size <= 8;
      }

      elem_type = seq_elem_supertype(type);
      fail if elem_type == empty_type;
      return :seq(interface_type(elem_type, rem_depth));
    }


    InterType set_interface_type(NeType type, NzNat depth) {
      elem_type = set_elem_supertype(type);
      fail if elem_type == empty_type;
      return :set(interface_type(elem_type, nat(depth-1)));
    }


    InterType map_record_interface_type(NeType type, NzNat depth) {
      rem_depth = nat(depth - 1);

      maybe_fields = maybe_record_type_fields(type);
      if maybe_fields != nothing {
        types = value(maybe_fields);
        if not (l info <- types : info.optional)
          return :record([untag(l) -> interface_type(info.type, rem_depth) : l info <- types]);
      }

      key_type, value_type = bin_rel_args_supertypes(type);
      fail if value_type == empty_type;

      key_inter_type = :generic;
      for it <- (:integer, :string, :date, :time)
        key_inter_type = it if is_subset(key_type, internal_type(it));

      value_inter_type = interface_type(value_type, rem_depth);

      return :map(key_inter_type, value_inter_type);
    }


    InterType bin_rel_interface_type(NeType type, NzNat depth) {
      return :generic;
    }


    // InterType tern_rel_interface_type(NeType type, NzNat depth) {
    //   args_types = tern_rel_args_supertypes(type);
    //   fail if not args_types :: (NeType, NeType, NeType);
    //   return :tern_rel((interface_type(t) : t <- args_types));
    // }


    InterType monomorphically_tagged_values_interface_type(NeType type, NzNat depth) {
      tag = untag(only_symb(tag_supertype(type)));
      untagged_type = untagged_objs_supertype(type);
      fail if untagged_type == empty_type;
      untagged_inter_type = interface_type(untagged_type, nat(depth-1));
      return :tagged(tag, untagged_inter_type);
    }


    InterType maybe_value_interface_type(NeType type, NzNat depth) {
      inner_type = maybe_type_type_param(type);
      return :optional(interface_type(inner_type, depth));
    }


    InterType symbols_and_tagged_values_interface_type(NeType type, NzNat depth) =
      union_type(ts?) = union_type_interface_type(ts, depth),
      symb_type(s?)   = :symbol(untag(s)),
      _               = :generic;


    InterType union_type_interface_type([+NeType] types, NzNat depth) {
      exp_types = (expand_top_level_type_refs(t) : t <- isort(types));
      if exp_types :: < SymbType, tag_obj_type(tag_type: SymbType, obj_type: NeType),
                        union_type([+<SymbType, tag_obj_type(tag_type: SymbType, obj_type: NeType)>])
                      >+ {
        symbols = (
          match (exp_type)
            symb_type(s?)   = [untag(s)],
            tag_obj_type()  = [],
            union_type(ts?) = [untag(t) : t <- ts, symb_type() ?= t]
          : exp_type <- exp_types
        );

        tags = (
          match (exp_type)
            symb_type()     = [],
            tag_obj_type()  = [untag(exp_type.tag_type)],
            union_type(ts?) = [untag(t.tag_type) : t <- ts, tag_obj_type() ?= t]
          : exp_type <- exp_types
        );

        if not intersect(symbols) and not intersect(tags) {
          rem_depth = nat(depth - 1);
          inter_types = [interface_type(t, rem_depth) : t <- types];
          return :union(inter_types) if inter_types :: [+UnionAltInterType];
        }
      }
      return :generic;
    }
  }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

## DOESN'T IT ALREADY EXIST, EITHER IN THE STANDARD LIBRARY OR ELSEWHERE?
Bool intersect([T]* sets) {
  for s1 @ i1 <- sets {
    for i2 = i1+1 .. |sets| {
      s2 = sets(i2);
      return true if (x <- s1 : s2(x));
    }
  }
  return false;
}


implicit typedefs : [TypeName -> NeType] {
  NeType expand_top_level_type_refs(NeType type) =
    symb_type()         |
    atom_type           |
    integer             |
    low_ints()          |
    high_ints()         |
    int_range()         |
    float_type          |
    empty_seq_type      |
    empty_rel_type      |
    type_var()          |
    ne_seq_type()       |
    ne_set_type()       |
    ne_map_type()       |
    ne_bin_rel_type()   |
    ne_tern_rel_type()  |
    ne_record_type()    |
    tuple_type()        |
    tag_obj_type()      = type,
    type_ref(ts?)       = expand_top_level_type_refs(cast_ne_type(expand_type_ref(ts, typedefs))),
    union_type(ts?)     = ne_union_type([expand_top_level_type_refs(t) : t <- ts]);
}


[NamedInterType] nested_named_types(InterType inter_type) =
  named() = [inter_type],
  _       = search_nested(inter_type, nested_named_types);


[X] search_nested(InterType inter_type, (InterType -> [X]) nested) =
  bool            |
  integer         |
  float           |
  string          |
  date            |
  time            |
  generic         |
  symbol()        |
  named()         = [],
  tuple(ts?)      = [x : t <- ts, x <- nested(t)],
  record(fs?)     = [x : _ t <- fs, x <- nested(t)],
  union(ts?)      = [x : t <- ts, x <- nested(t)],
  tagged(_, t?)   |
  optional(t?)    |
  seq(t?)         |
  set(t?)         = nested(t),
  map(k?, v?)     = nested(k) & nested(v);


String symb_idx_base_name(<Atom, SymbObj> symb) = symb_idx_name(symb, context=:core);
String symb_idx_qual_name(<Atom, SymbObj> symb) = symb_idx_name(symb, context=:wrapper);
